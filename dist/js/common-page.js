webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _jquery = __webpack_require__(1);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\n__webpack_require__(2);\n\n__webpack_require__(3);\n\nvar _scrollmagic = __webpack_require__(5);\n\nvar _scrollmagic2 = _interopRequireDefault(_scrollmagic);\n\n__webpack_require__(6);\n\n__webpack_require__(9);\n\nvar _select = __webpack_require__(53);\n\nvar _select2 = _interopRequireDefault(_select);\n\nvar _navColorChange = __webpack_require__(106);\n\nvar _navColorChange2 = _interopRequireDefault(_navColorChange);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*global TweenMax*/\n\n(0, _select2.default)(_jquery2.default);\n(0, _jquery2.default)('.select').select();\n\n(0, _navColorChange2.default)();\n\n(function () {\n\n    var mapLocationSelect = (0, _jquery2.default)('.map-select');\n\n    if (!mapLocationSelect.length) return;\n\n    mapLocationSelect.select({\n        selectors: {\n            button: '.map-select__current span',\n            option: '.map-select__item'\n        }\n    });\n\n    mapLocationSelect.on('change', function (e, val) {\n        console.log(val);\n    });\n})();\n\n(function () {\n\n    /**\n     * Parallax for logotype on red background\n     */\n\n    var redLine = (0, _jquery2.default)('.v-line');\n\n    if (!redLine.length) return;\n\n    var controller = new _scrollmagic2.default.Controller({ container: 'body' });\n    var logotype = redLine.find('.logotype-full');\n    var duration = redLine.outerHeight();\n    var factor = 0.7;\n\n    new _scrollmagic2.default.Scene({\n        duration: duration,\n        triggerElement: redLine[0],\n        triggerHook: 'onLeave'\n    }).on('progress', function (e) {\n\n        TweenMax.set(logotype, {\n            y: duration * e.progress * factor\n        });\n    }).addTo(controller);\n})();\n\n(0, _jquery2.default)('html').removeClass('no-js');\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvY29tbW9uLXBhZ2UuanM/MjE2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBUd2Vlbk1heCovXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0ICdzdmd4dXNlJztcbmltcG9ydCAnZ3NhcCc7XG5pbXBvcnQgU2Nyb2xsTWFnaWMgZnJvbSAnc2Nyb2xsbWFnaWMnO1xuXG5pbXBvcnQgJy4vbW9kdWxlcy9tZW51JztcbmltcG9ydCAnLi9tb2R1bGVzL2NhbGN1bGF0b3InO1xuXG5pbXBvcnQgaW5pdFNlbGVjdFBsdWdpbiBmcm9tICcuL3BsdWdpbnMvc2VsZWN0JztcbmltcG9ydCBuYXZDb2xvckNoYW5nZSBmcm9tICcuL3BsdWdpbnMvbmF2LWNvbG9yLWNoYW5nZSc7XG5cbmluaXRTZWxlY3RQbHVnaW4oJCk7XG4kKCcuc2VsZWN0Jykuc2VsZWN0KCk7XG5cbm5hdkNvbG9yQ2hhbmdlKCk7XG5cblxuKCgpID0+IHtcblxuICAgIGNvbnN0IG1hcExvY2F0aW9uU2VsZWN0ID0gJCgnLm1hcC1zZWxlY3QnKTtcblxuICAgIGlmICghbWFwTG9jYXRpb25TZWxlY3QubGVuZ3RoKSByZXR1cm47XG5cbiAgICBtYXBMb2NhdGlvblNlbGVjdC5zZWxlY3Qoe1xuICAgICAgICBzZWxlY3RvcnM6IHtcbiAgICAgICAgICAgIGJ1dHRvbjogJy5tYXAtc2VsZWN0X19jdXJyZW50IHNwYW4nLFxuICAgICAgICAgICAgb3B0aW9uOiAnLm1hcC1zZWxlY3RfX2l0ZW0nXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG1hcExvY2F0aW9uU2VsZWN0Lm9uKCdjaGFuZ2UnLCAoZSwgdmFsKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKHZhbCk7XG4gICAgfSk7XG5cbn0pKCk7XG5cblxuKCgpID0+IHtcblxuICAgIC8qKlxuICAgICAqIFBhcmFsbGF4IGZvciBsb2dvdHlwZSBvbiByZWQgYmFja2dyb3VuZFxuICAgICAqL1xuXG4gICAgY29uc3QgcmVkTGluZSA9ICQoJy52LWxpbmUnKTtcblxuICAgIGlmICghcmVkTGluZS5sZW5ndGgpIHJldHVybjtcblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgICAgPSBuZXcgU2Nyb2xsTWFnaWMuQ29udHJvbGxlcih7IGNvbnRhaW5lcjogJ2JvZHknIH0pO1xuICAgIGNvbnN0IGxvZ290eXBlICAgICAgPSByZWRMaW5lLmZpbmQoJy5sb2dvdHlwZS1mdWxsJyk7XG4gICAgY29uc3QgZHVyYXRpb24gICAgICA9IHJlZExpbmUub3V0ZXJIZWlnaHQoKTtcbiAgICBjb25zdCBmYWN0b3IgICAgICAgID0gMC43O1xuXG4gICAgbmV3IFNjcm9sbE1hZ2ljLlNjZW5lKHtcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIHRyaWdnZXJFbGVtZW50OiByZWRMaW5lWzBdLFxuICAgICAgICB0cmlnZ2VySG9vazogJ29uTGVhdmUnXG4gICAgfSkub24oJ3Byb2dyZXNzJywgKGUpID0+IHtcblxuICAgICAgICBUd2Vlbk1heC5zZXQobG9nb3R5cGUsIHtcbiAgICAgICAgICAgIHk6IGR1cmF0aW9uICogZS5wcm9ncmVzcyAqIGZhY3RvclxuICAgICAgICB9KTtcblxuICAgIH0pLmFkZFRvKGNvbnRyb2xsZXIpO1xuXG59KSgpO1xuXG4kKCdodG1sJykucmVtb3ZlQ2xhc3MoJ25vLWpzJyk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvanMvY29tbW9uLXBhZ2UuanNcbiAqKi8iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFEQTtBQWJBO0FBQ0E7QUFtQkE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBREE7QUFGQTtBQW5CQTtBQUNBO0FBNEJBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _slicedToArray2 = __webpack_require__(10);\n\nvar _slicedToArray3 = _interopRequireDefault(_slicedToArray2);\n\nvar _jquery = __webpack_require__(1);\n\nvar _jquery2 = _interopRequireDefault(_jquery);\n\nvar _nouislider = __webpack_require__(52);\n\nvar _nouislider2 = _interopRequireDefault(_nouislider);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n(function () {\n\n    var container = (0, _jquery2.default)('.calc');\n\n    if (!container.length) return;\n\n    var root = (0, _jquery2.default)('body');\n    var sliderContainer = container.find('.slider');\n    var slider = sliderContainer.find('.slider__base');\n    var sliderValue = sliderContainer.find('.slider__value')[0].firstChild;\n    var totalValue = container.find('.calc__result');\n    var stowage = container.find('input[name=\"stowage\"]');\n    var reserve = container.find('input[name=\"reserve\"]');\n\n    var initialValue = 24;\n    var CAPACITY = 1.75;\n\n    var space = slider.data('init') || initialValue;\n    var timeout = null;\n\n    var _slider$data = slider.data();\n\n    var min = _slider$data.min;\n    var max = _slider$data.max;\n    var init = _slider$data.init;\n\n    _nouislider2.default.create(slider[0], {\n        start: init || initialValue,\n        range: {\n            min: min || 0,\n            max: max || 100\n        }\n    });\n\n    calculate(1);\n\n    var handle = slider.find('.noUi-handle');\n\n    handle.on('mousedown', function () {\n        sliderContainer.addClass('is-active');\n\n        root.one('mouseup', function () {\n            sliderContainer.removeClass('is-active');\n        });\n    });\n\n    stowage.on('change', calculate);\n    reserve.on('change', calculate);\n\n    slider[0].noUiSlider.on('slide', function (valuesStr, handleIndex, valuesInt, what) {\n        var _valuesInt = (0, _slicedToArray3.default)(valuesInt, 1);\n\n        space = _valuesInt[0];\n\n        calculate();\n    });\n\n    function formatValue(space) {\n        return space.toFixed(1).replace('.', ',') + ' ';\n    }\n\n    function getPackAmount(space) {\n        return space * (+stowage.filter(':checked').val() || 1) * (+reserve.filter(':checked').val() || 1) / CAPACITY;\n    }\n\n    function highlight() {\n        totalValue.addClass('omg');\n        setTimeout(function () {\n            return totalValue.removeClass('omg');\n        }, 500);\n    }\n\n    function calculate(silent) {\n        sliderValue.textContent = formatValue(space);\n        totalValue.text(Math.ceil(getPackAmount(space)));\n\n        if (silent) return;\n        clearTimeout(timeout);\n        timeout = setTimeout(highlight, 200);\n    }\n})();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvanMvbW9kdWxlcy9jYWxjdWxhdG9yLmpzPzk5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICQgZnJvbSAnanF1ZXJ5JztcbmltcG9ydCBub1VpU2xpZGVyIGZyb20gJ25vdWlzbGlkZXInO1xuXG4oKCkgPT4ge1xuXG4gICAgY29uc3QgY29udGFpbmVyID0gJCgnLmNhbGMnKTtcblxuICAgIGlmICghY29udGFpbmVyLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgY29uc3Qgcm9vdCAgICAgICAgICAgICAgID0gJCgnYm9keScpO1xuICAgIGNvbnN0IHNsaWRlckNvbnRhaW5lciAgICA9IGNvbnRhaW5lci5maW5kKCcuc2xpZGVyJyk7XG4gICAgY29uc3Qgc2xpZGVyICAgICAgICAgICAgID0gc2xpZGVyQ29udGFpbmVyLmZpbmQoJy5zbGlkZXJfX2Jhc2UnKTtcbiAgICBjb25zdCBzbGlkZXJWYWx1ZSAgICAgICAgPSBzbGlkZXJDb250YWluZXIuZmluZCgnLnNsaWRlcl9fdmFsdWUnKVswXS5maXJzdENoaWxkO1xuICAgIGNvbnN0IHRvdGFsVmFsdWUgICAgICAgICA9IGNvbnRhaW5lci5maW5kKCcuY2FsY19fcmVzdWx0Jyk7XG4gICAgY29uc3Qgc3Rvd2FnZSAgICAgICAgICAgID0gY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJzdG93YWdlXCJdJyk7XG4gICAgY29uc3QgcmVzZXJ2ZSAgICAgICAgICAgID0gY29udGFpbmVyLmZpbmQoJ2lucHV0W25hbWU9XCJyZXNlcnZlXCJdJyk7XG5cbiAgICBjb25zdCBpbml0aWFsVmFsdWUgICAgICAgPSAyNDtcbiAgICBjb25zdCBDQVBBQ0lUWSAgICAgICAgICAgPSAxLjc1O1xuXG4gICAgbGV0IHNwYWNlICAgICAgICAgICAgICAgID0gc2xpZGVyLmRhdGEoJ2luaXQnKSB8fCBpbml0aWFsVmFsdWU7XG4gICAgbGV0IHRpbWVvdXQgICAgICAgICAgICAgID0gbnVsbDtcblxuICAgIGNvbnN0IHsgbWluLCBtYXgsIGluaXQgfSA9IHNsaWRlci5kYXRhKCk7XG5cbiAgICBub1VpU2xpZGVyLmNyZWF0ZShzbGlkZXJbMF0sIHtcbiAgICAgICAgc3RhcnQ6IGluaXQgfHwgaW5pdGlhbFZhbHVlLFxuICAgICAgICByYW5nZToge1xuICAgICAgICAgICAgbWluOiBtaW4gfHwgMCxcbiAgICAgICAgICAgIG1heDogbWF4IHx8IDEwMFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjYWxjdWxhdGUoMSk7XG5cbiAgICBjb25zdCBoYW5kbGUgPSBzbGlkZXIuZmluZCgnLm5vVWktaGFuZGxlJyk7XG5cbiAgICBoYW5kbGUub24oJ21vdXNlZG93bicsICgpID0+IHtcbiAgICAgICAgc2xpZGVyQ29udGFpbmVyLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcblxuICAgICAgICByb290Lm9uZSgnbW91c2V1cCcsICgpID0+IHtcbiAgICAgICAgICAgIHNsaWRlckNvbnRhaW5lci5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc3Rvd2FnZS5vbignY2hhbmdlJywgY2FsY3VsYXRlKTtcbiAgICByZXNlcnZlLm9uKCdjaGFuZ2UnLCBjYWxjdWxhdGUpO1xuXG4gICAgc2xpZGVyWzBdLm5vVWlTbGlkZXIub24oJ3NsaWRlJywgZnVuY3Rpb24odmFsdWVzU3RyLCBoYW5kbGVJbmRleCwgdmFsdWVzSW50LCB3aGF0KSB7XG4gICAgICAgIFsgc3BhY2UgXSA9IHZhbHVlc0ludDtcbiAgICAgICAgY2FsY3VsYXRlKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRWYWx1ZShzcGFjZSkge1xuICAgICAgICByZXR1cm4gYCR7c3BhY2UudG9GaXhlZCgxKS5yZXBsYWNlKCcuJywgJywnKX0gYDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRQYWNrQW1vdW50KHNwYWNlKSB7XG4gICAgICAgIHJldHVybiBzcGFjZVxuICAgICAgICAgICAgKiAoK3N0b3dhZ2UuZmlsdGVyKCc6Y2hlY2tlZCcpLnZhbCgpIHx8IDEpXG4gICAgICAgICAgICAqICgrcmVzZXJ2ZS5maWx0ZXIoJzpjaGVja2VkJykudmFsKCkgfHwgMSlcbiAgICAgICAgICAgIC8gQ0FQQUNJVFk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGlnaGxpZ2h0KCkge1xuICAgICAgICB0b3RhbFZhbHVlLmFkZENsYXNzKCdvbWcnKTtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0b3RhbFZhbHVlLnJlbW92ZUNsYXNzKCdvbWcnKSwgNTAwKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGUoc2lsZW50KSB7XG4gICAgICAgIHNsaWRlclZhbHVlLnRleHRDb250ZW50ID0gZm9ybWF0VmFsdWUoc3BhY2UpO1xuICAgICAgICB0b3RhbFZhbHVlLnRleHQoTWF0aC5jZWlsKGdldFBhY2tBbW91bnQoc3BhY2UpKSk7XG5cbiAgICAgICAgaWYgKHNpbGVudCkgcmV0dXJuO1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGhpZ2hsaWdodCwgMjAwKTtcbiAgICB9XG5cbn0pKCk7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiBzcmMvanMvbW9kdWxlcy9jYWxjdWxhdG9yLmpzXG4gKiovIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUZBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUhBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBREE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQWxFQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("\"use strict\";\n\nexports.__esModule = true;\n\nvar _isIterable2 = __webpack_require__(11);\n\nvar _isIterable3 = _interopRequireDefault(_isIterable2);\n\nvar _getIterator2 = __webpack_require__(46);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = (function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if ((0, _isIterable3.default)(Object(arr))) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n})();\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9iYWJlbC1ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcz9iOGU2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2lzSXRlcmFibGUyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvaXMtaXRlcmFibGVcIik7XG5cbnZhciBfaXNJdGVyYWJsZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pc0l0ZXJhYmxlMik7XG5cbnZhciBfZ2V0SXRlcmF0b3IyID0gcmVxdWlyZShcIi4uL2NvcmUtanMvZ2V0LWl0ZXJhdG9yXCIpO1xuXG52YXIgX2dldEl0ZXJhdG9yMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldEl0ZXJhdG9yMik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7XG4gICAgdmFyIF9hcnIgPSBbXTtcbiAgICB2YXIgX24gPSB0cnVlO1xuICAgIHZhciBfZCA9IGZhbHNlO1xuICAgIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaSA9ICgwLCBfZ2V0SXRlcmF0b3IzLmRlZmF1bHQpKGFyciksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2QgPSB0cnVlO1xuICAgICAgX2UgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0pIF9pW1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfYXJyO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH0gZWxzZSBpZiAoKDAsIF9pc0l0ZXJhYmxlMy5kZWZhdWx0KShPYmplY3QoYXJyKSkpIHtcbiAgICAgIHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2JhYmVsLXJ1bnRpbWUvaGVscGVycy9zbGljZWRUb0FycmF5LmpzXG4gKiogbW9kdWxlIGlkID0gMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = { \"default\": __webpack_require__(12), __esModule: true };\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvaXMtaXRlcmFibGUuanM/OGM5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9idXNjaGlkb3Mvd29yay9naXQvcmVzdWx0L34vYmFiZWwtcnVudGltZS9jb3JlLWpzL2lzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(13);\n__webpack_require__(41);\nmodule.exports = __webpack_require__(44);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvZm4vaXMtaXRlcmFibGUuanM/MzY2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuaXMtaXRlcmFibGUnKTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9idXNjaGlkb3Mvd29yay9naXQvcmVzdWx0L34vY29yZS1qcy9saWJyYXJ5L2ZuL2lzLWl0ZXJhYmxlLmpzXG4gKiogbW9kdWxlIGlkID0gMTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(14);\nvar Iterators = __webpack_require__(17);\nIterators.NodeList = Iterators.HTMLCollection = Iterators.Array;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlLmpzPzM4MzYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9lczYuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5JdGVyYXRvcnMuTm9kZUxpc3QgPSBJdGVyYXRvcnMuSFRNTENvbGxlY3Rpb24gPSBJdGVyYXRvcnMuQXJyYXk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAxM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwIDJcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar addToUnscopables = __webpack_require__(15)\n  , step             = __webpack_require__(16)\n  , Iterators        = __webpack_require__(17)\n  , toIObject        = __webpack_require__(18);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(22)(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanM/NmUyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4vJC5hZGQtdG8tdW5zY29wYWJsZXMnKVxuICAsIHN0ZXAgICAgICAgICAgICAgPSByZXF1aXJlKCcuLyQuaXRlci1zdGVwJylcbiAgLCBJdGVyYXRvcnMgICAgICAgID0gcmVxdWlyZSgnLi8kLml0ZXJhdG9ycycpXG4gICwgdG9JT2JqZWN0ICAgICAgICA9IHJlcXVpcmUoJy4vJC50by1pb2JqZWN0Jyk7XG5cbi8vIDIyLjEuMy40IEFycmF5LnByb3RvdHlwZS5lbnRyaWVzKClcbi8vIDIyLjEuMy4xMyBBcnJheS5wcm90b3R5cGUua2V5cygpXG4vLyAyMi4xLjMuMjkgQXJyYXkucHJvdG90eXBlLnZhbHVlcygpXG4vLyAyMi4xLjMuMzAgQXJyYXkucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLml0ZXItZGVmaW5lJykoQXJyYXksICdBcnJheScsIGZ1bmN0aW9uKGl0ZXJhdGVkLCBraW5kKXtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbigpe1xuICB2YXIgTyAgICAgPSB0aGlzLl90XG4gICAgLCBraW5kICA9IHRoaXMuX2tcbiAgICAsIGluZGV4ID0gdGhpcy5faSsrO1xuICBpZighTyB8fCBpbmRleCA+PSBPLmxlbmd0aCl7XG4gICAgdGhpcy5fdCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc3RlcCgxKTtcbiAgfVxuICBpZihraW5kID09ICdrZXlzJyAgKXJldHVybiBzdGVwKDAsIGluZGV4KTtcbiAgaWYoa2luZCA9PSAndmFsdWVzJylyZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMlxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports) {

	eval("module.exports = function(){ /* empty */ };\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmFkZC10by11bnNjb3BhYmxlcy5qcz81NDE5Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKXsgLyogZW1wdHkgKi8gfTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9idXNjaGlkb3Mvd29yay9naXQvcmVzdWx0L34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5hZGQtdG8tdW5zY29wYWJsZXMuanNcbiAqKiBtb2R1bGUgaWQgPSAxNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwIDJcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports) {

	eval("module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItc3RlcC5qcz9kZmVjIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZG9uZSwgdmFsdWUpe1xuICByZXR1cm4ge3ZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlci1zdGVwLmpzXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAyXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports) {

	eval("module.exports = {};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXJhdG9ycy5qcz84ZDY4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuaXRlcmF0b3JzLmpzXG4gKiogbW9kdWxlIGlkID0gMTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAyXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 18 */,
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar LIBRARY        = __webpack_require__(23)\n  , $export        = __webpack_require__(24)\n  , redefine       = __webpack_require__(29)\n  , hide           = __webpack_require__(30)\n  , has            = __webpack_require__(35)\n  , Iterators      = __webpack_require__(17)\n  , $iterCreate    = __webpack_require__(36)\n  , setToStringTag = __webpack_require__(37)\n  , getProto       = __webpack_require__(31).getProto\n  , ITERATOR       = __webpack_require__(38)('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , methods, key;\n  // Fix native\n  if($native){\n    var IteratorPrototype = getProto($default.call(new Base));\n    // Set @@toStringTag to native iterators\n    setToStringTag(IteratorPrototype, TAG, true);\n    // FF fix\n    if(!LIBRARY && has(proto, FF_ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    // fix Array#{values, @@iterator}.name in V8 / FF\n    if(DEF_VALUES && $native.name !== VALUES){\n      VALUES_BUG = true;\n      $default = function values(){ return $native.call(this); };\n    }\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES  ? $default : getMethod(VALUES),\n      keys:    IS_SET      ? $default : getMethod(KEYS),\n      entries: !DEF_VALUES ? $default : getMethod('entries')\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItZGVmaW5lLmpzPzcxZWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyIExJQlJBUlkgICAgICAgID0gcmVxdWlyZSgnLi8kLmxpYnJhcnknKVxuICAsICRleHBvcnQgICAgICAgID0gcmVxdWlyZSgnLi8kLmV4cG9ydCcpXG4gICwgcmVkZWZpbmUgICAgICAgPSByZXF1aXJlKCcuLyQucmVkZWZpbmUnKVxuICAsIGhpZGUgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhpZGUnKVxuICAsIGhhcyAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kLmhhcycpXG4gICwgSXRlcmF0b3JzICAgICAgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJylcbiAgLCAkaXRlckNyZWF0ZSAgICA9IHJlcXVpcmUoJy4vJC5pdGVyLWNyZWF0ZScpXG4gICwgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLyQuc2V0LXRvLXN0cmluZy10YWcnKVxuICAsIGdldFByb3RvICAgICAgID0gcmVxdWlyZSgnLi8kJykuZ2V0UHJvdG9cbiAgLCBJVEVSQVRPUiAgICAgICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEJVR0dZICAgICAgICAgID0gIShbXS5rZXlzICYmICduZXh0JyBpbiBbXS5rZXlzKCkpIC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgLCBGRl9JVEVSQVRPUiAgICA9ICdAQGl0ZXJhdG9yJ1xuICAsIEtFWVMgICAgICAgICAgID0gJ2tleXMnXG4gICwgVkFMVUVTICAgICAgICAgPSAndmFsdWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbigpeyByZXR1cm4gdGhpczsgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihCYXNlLCBOQU1FLCBDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpe1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbihraW5kKXtcbiAgICBpZighQlVHR1kgJiYga2luZCBpbiBwcm90bylyZXR1cm4gcHJvdG9ba2luZF07XG4gICAgc3dpdGNoKGtpbmQpe1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgICAgY2FzZSBWQUxVRVM6IHJldHVybiBmdW5jdGlvbiB2YWx1ZXMoKXsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICB9IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCl7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgICAgICAgID0gTkFNRSArICcgSXRlcmF0b3InXG4gICAgLCBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVNcbiAgICAsIFZBTFVFU19CVUcgPSBmYWxzZVxuICAgICwgcHJvdG8gICAgICA9IEJhc2UucHJvdG90eXBlXG4gICAgLCAkbmF0aXZlICAgID0gcHJvdG9bSVRFUkFUT1JdIHx8IHByb3RvW0ZGX0lURVJBVE9SXSB8fCBERUZBVUxUICYmIHByb3RvW0RFRkFVTFRdXG4gICAgLCAkZGVmYXVsdCAgID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVClcbiAgICAsIG1ldGhvZHMsIGtleTtcbiAgLy8gRml4IG5hdGl2ZVxuICBpZigkbmF0aXZlKXtcbiAgICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90bygkZGVmYXVsdC5jYWxsKG5ldyBCYXNlKSk7XG4gICAgLy8gU2V0IEBAdG9TdHJpbmdUYWcgdG8gbmF0aXZlIGl0ZXJhdG9yc1xuICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgIC8vIEZGIGZpeFxuICAgIGlmKCFMSUJSQVJZICYmIGhhcyhwcm90bywgRkZfSVRFUkFUT1IpKWhpZGUoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gICAgaWYoREVGX1ZBTFVFUyAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUyl7XG4gICAgICBWQUxVRVNfQlVHID0gdHJ1ZTtcbiAgICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCl7IHJldHVybiAkbmF0aXZlLmNhbGwodGhpcyk7IH07XG4gICAgfVxuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZigoIUxJQlJBUlkgfHwgRk9SQ0VEKSAmJiAoQlVHR1kgfHwgVkFMVUVTX0JVRyB8fCAhcHJvdG9bSVRFUkFUT1JdKSl7XG4gICAgaGlkZShwcm90bywgSVRFUkFUT1IsICRkZWZhdWx0KTtcbiAgfVxuICAvLyBQbHVnIGZvciBsaWJyYXJ5XG4gIEl0ZXJhdG9yc1tOQU1FXSA9ICRkZWZhdWx0O1xuICBJdGVyYXRvcnNbVEFHXSAgPSByZXR1cm5UaGlzO1xuICBpZihERUZBVUxUKXtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiAgREVGX1ZBTFVFUyAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChWQUxVRVMpLFxuICAgICAga2V5czogICAgSVNfU0VUICAgICAgPyAkZGVmYXVsdCA6IGdldE1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6ICFERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoJ2VudHJpZXMnKVxuICAgIH07XG4gICAgaWYoRk9SQ0VEKWZvcihrZXkgaW4gbWV0aG9kcyl7XG4gICAgICBpZighKGtleSBpbiBwcm90bykpcmVkZWZpbmUocHJvdG8sIGtleSwgbWV0aG9kc1trZXldKTtcbiAgICB9IGVsc2UgJGV4cG9ydCgkZXhwb3J0LlAgKyAkZXhwb3J0LkYgKiAoQlVHR1kgfHwgVkFMVUVTX0JVRyksIE5BTUUsIG1ldGhvZHMpO1xuICB9XG4gIHJldHVybiBtZXRob2RzO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9idXNjaGlkb3Mvd29yay9naXQvcmVzdWx0L34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWRlZmluZS5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMlxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $              = __webpack_require__(31)\n  , descriptor     = __webpack_require__(32)\n  , setToStringTag = __webpack_require__(37)\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(30)(IteratorPrototype, __webpack_require__(38)('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = $.create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLml0ZXItY3JlYXRlLmpzPzY4NTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICQgICAgICAgICAgICAgID0gcmVxdWlyZSgnLi8kJylcbiAgLCBkZXNjcmlwdG9yICAgICA9IHJlcXVpcmUoJy4vJC5wcm9wZXJ0eS1kZXNjJylcbiAgLCBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vJC5zZXQtdG8tc3RyaW5nLXRhZycpXG4gICwgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKSwgZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKENvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KXtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gJC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHtuZXh0OiBkZXNjcmlwdG9yKDEsIG5leHQpfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9idXNjaGlkb3Mvd29yay9naXQvcmVzdWx0L34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvJC5pdGVyLWNyZWF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM2XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMlxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\nvar $at  = __webpack_require__(42)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(22)(String, 'String', function(iterated){\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , index = this._i\n    , point;\n  if(index >= O.length)return {value: undefined, done: true};\n  point = $at(O, index);\n  this._i += point.length;\n  return {value: point, done: false};\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzPzBjYWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xudmFyICRhdCAgPSByZXF1aXJlKCcuLyQuc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vJC5pdGVyLWRlZmluZScpKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uKGl0ZXJhdGVkKXtcbiAgdGhpcy5fdCA9IFN0cmluZyhpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuLy8gMjEuMS41LjIuMSAlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlLm5leHQoKVxufSwgZnVuY3Rpb24oKXtcbiAgdmFyIE8gICAgID0gdGhpcy5fdFxuICAgICwgaW5kZXggPSB0aGlzLl9pXG4gICAgLCBwb2ludDtcbiAgaWYoaW5kZXggPj0gTy5sZW5ndGgpcmV0dXJuIHt2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlfTtcbiAgcG9pbnQgPSAkYXQoTywgaW5kZXgpO1xuICB0aGlzLl9pICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHt2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlfTtcbn0pO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuc3RyaW5nLml0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAyXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	eval("var toInteger = __webpack_require__(43)\n  , defined   = __webpack_require__(21);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnN0cmluZy1hdC5qcz9kZDI5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLyQudG8taW50ZWdlcicpXG4gICwgZGVmaW5lZCAgID0gcmVxdWlyZSgnLi8kLmRlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFRPX1NUUklORyl7XG4gIHJldHVybiBmdW5jdGlvbih0aGF0LCBwb3Mpe1xuICAgIHZhciBzID0gU3RyaW5nKGRlZmluZWQodGhhdCkpXG4gICAgICAsIGkgPSB0b0ludGVnZXIocG9zKVxuICAgICAgLCBsID0gcy5sZW5ndGhcbiAgICAgICwgYSwgYjtcbiAgICBpZihpIDwgMCB8fCBpID49IGwpcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuc3RyaW5nLWF0LmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMCAyXG4gKiovIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 43 */
/***/ function(module, exports) {

	eval("// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLnRvLWludGVnZXIuanM/MjBlYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsICA9IE1hdGguY2VpbFxuICAsIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXQpe1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQudG8taW50ZWdlci5qc1xuICoqIG1vZHVsZSBpZCA9IDQzXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMlxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	eval("var classof   = __webpack_require__(45)\n  , ITERATOR  = __webpack_require__(38)('iterator')\n  , Iterators = __webpack_require__(17);\nmodule.exports = __webpack_require__(26).isIterable = function(it){\n  var O = Object(it);\n  return O[ITERATOR] !== undefined\n    || '@@iterator' in O\n    || Iterators.hasOwnProperty(classof(O));\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmlzLWl0ZXJhYmxlLmpzPzVlNjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNsYXNzb2YgICA9IHJlcXVpcmUoJy4vJC5jbGFzc29mJylcbiAgLCBJVEVSQVRPUiAgPSByZXF1aXJlKCcuLyQud2tzJykoJ2l0ZXJhdG9yJylcbiAgLCBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLyQuaXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJC5jb3JlJykuaXNJdGVyYWJsZSA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8gPSBPYmplY3QoaXQpO1xuICByZXR1cm4gT1tJVEVSQVRPUl0gIT09IHVuZGVmaW5lZFxuICAgIHx8ICdAQGl0ZXJhdG9yJyBpbiBPXG4gICAgfHwgSXRlcmF0b3JzLmhhc093blByb3BlcnR5KGNsYXNzb2YoTykpO1xufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9idXNjaGlkb3Mvd29yay9naXQvcmVzdWx0L34vY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5pcy1pdGVyYWJsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(20)\n  , TAG = __webpack_require__(38)('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = (O = Object(it))[TAG]) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy8kLmNsYXNzb2YuanM/OTlkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnZXR0aW5nIHRhZyBmcm9tIDE5LjEuMy42IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcoKVxudmFyIGNvZiA9IHJlcXVpcmUoJy4vJC5jb2YnKVxuICAsIFRBRyA9IHJlcXVpcmUoJy4vJC53a3MnKSgndG9TdHJpbmdUYWcnKVxuICAvLyBFUzMgd3JvbmcgaGVyZVxuICAsIEFSRyA9IGNvZihmdW5jdGlvbigpeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIE8sIFQsIEI7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mIChUID0gKE8gPSBPYmplY3QoaXQpKVtUQUddKSA9PSAnc3RyaW5nJyA/IFRcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IEFSRyA/IGNvZihPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChCID0gY29mKE8pKSA9PSAnT2JqZWN0JyAmJiB0eXBlb2YgTy5jYWxsZWUgPT0gJ2Z1bmN0aW9uJyA/ICdBcmd1bWVudHMnIDogQjtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzLyQuY2xhc3NvZi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ1XG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMlxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = { \"default\": __webpack_require__(47), __esModule: true };\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzPzIzMDUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2dldC1pdGVyYXRvclwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(13);\n__webpack_require__(41);\nmodule.exports = __webpack_require__(48);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzP2EyZTIiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuZG9tLml0ZXJhYmxlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvcicpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	eval("var anObject = __webpack_require__(49)\n  , get      = __webpack_require__(51);\nmodule.exports = __webpack_require__(26).getIterator = function(it){\n  var iterFn = get(it);\n  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qcz9jMjZhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vJC5hbi1vYmplY3QnKVxuICAsIGdldCAgICAgID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uKGl0KXtcbiAgdmFyIGl0ZXJGbiA9IGdldChpdCk7XG4gIGlmKHR5cGVvZiBpdGVyRm4gIT0gJ2Z1bmN0aW9uJyl0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 49 */,
/* 50 */,
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	eval("var classof   = __webpack_require__(45)\n  , ITERATOR  = __webpack_require__(38)('iterator')\n  , Iterators = __webpack_require__(17);\nmodule.exports = __webpack_require__(26).getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QuanM/ZjgzZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY2xhc3NvZiAgID0gcmVxdWlyZSgnLi8kLmNsYXNzb2YnKVxuICAsIElURVJBVE9SICA9IHJlcXVpcmUoJy4vJC53a3MnKSgnaXRlcmF0b3InKVxuICAsIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vJC5pdGVyYXRvcnMnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8kLmNvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uKGl0KXtcbiAgaWYoaXQgIT0gdW5kZWZpbmVkKXJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvYnVzY2hpZG9zL3dvcmsvZ2l0L3Jlc3VsdC9+L2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qc1xuICoqIG1vZHVsZSBpZCA9IDUxXG4gKiogbW9kdWxlIGNodW5rcyA9IDAgMlxuICoqLyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! nouislider - 8.2.1 - 2015-12-02 21:43:14 */\r\n\r\n(function (factory) {\r\n\r\n    if ( true ) {\r\n\r\n        // AMD. Register as an anonymous module.\r\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n    } else if ( typeof exports === 'object' ) {\r\n\r\n        // Node/CommonJS\r\n        module.exports = factory();\r\n\r\n    } else {\r\n\r\n        // Browser globals\r\n        window.noUiSlider = factory();\r\n    }\r\n\r\n}(function( ){\r\n\r\n\t'use strict';\r\n\r\n\r\n\t// Removes duplicates from an array.\r\n\tfunction unique(array) {\r\n\t\treturn array.filter(function(a){\r\n\t\t\treturn !this[a] ? this[a] = true : false;\r\n\t\t}, {});\r\n\t}\r\n\r\n\t// Round a value to the closest 'to'.\r\n\tfunction closest ( value, to ) {\r\n\t\treturn Math.round(value / to) * to;\r\n\t}\r\n\r\n\t// Current position of an element relative to the document.\r\n\tfunction offset ( elem ) {\r\n\r\n\tvar rect = elem.getBoundingClientRect(),\r\n\t\tdoc = elem.ownerDocument,\r\n\t\tdocElem = doc.documentElement,\r\n\t\tpageOffset = getPageOffset();\r\n\r\n\t\t// getBoundingClientRect contains left scroll in Chrome on Android.\r\n\t\t// I haven't found a feature detection that proves this. Worst case\r\n\t\t// scenario on mis-match: the 'tap' feature on horizontal sliders breaks.\r\n\t\tif ( /webkit.*Chrome.*Mobile/i.test(navigator.userAgent) ) {\r\n\t\t\tpageOffset.x = 0;\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\ttop: rect.top + pageOffset.y - docElem.clientTop,\r\n\t\t\tleft: rect.left + pageOffset.x - docElem.clientLeft\r\n\t\t};\r\n\t}\r\n\r\n\t// Checks whether a value is numerical.\r\n\tfunction isNumeric ( a ) {\r\n\t\treturn typeof a === 'number' && !isNaN( a ) && isFinite( a );\r\n\t}\r\n\r\n\t// Rounds a number to 7 supported decimals.\r\n\tfunction accurateNumber( number ) {\r\n\t\tvar p = Math.pow(10, 7);\r\n\t\treturn Number((Math.round(number*p)/p).toFixed(7));\r\n\t}\r\n\r\n\t// Sets a class and removes it after [duration] ms.\r\n\tfunction addClassFor ( element, className, duration ) {\r\n\t\taddClass(element, className);\r\n\t\tsetTimeout(function(){\r\n\t\t\tremoveClass(element, className);\r\n\t\t}, duration);\r\n\t}\r\n\r\n\t// Limits a value to 0 - 100\r\n\tfunction limit ( a ) {\r\n\t\treturn Math.max(Math.min(a, 100), 0);\r\n\t}\r\n\r\n\t// Wraps a variable as an array, if it isn't one yet.\r\n\tfunction asArray ( a ) {\r\n\t\treturn Array.isArray(a) ? a : [a];\r\n\t}\r\n\r\n\t// Counts decimals\r\n\tfunction countDecimals ( numStr ) {\r\n\t\tvar pieces = numStr.split(\".\");\r\n\t\treturn pieces.length > 1 ? pieces[1].length : 0;\r\n\t}\r\n\r\n\t// http://youmightnotneedjquery.com/#add_class\r\n\tfunction addClass ( el, className ) {\r\n\t\tif ( el.classList ) {\r\n\t\t\tel.classList.add(className);\r\n\t\t} else {\r\n\t\t\tel.className += ' ' + className;\r\n\t\t}\r\n\t}\r\n\r\n\t// http://youmightnotneedjquery.com/#remove_class\r\n\tfunction removeClass ( el, className ) {\r\n\t\tif ( el.classList ) {\r\n\t\t\tel.classList.remove(className);\r\n\t\t} else {\r\n\t\t\tel.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\r\n\t\t}\r\n\t}\r\n\r\n\t// http://youmightnotneedjquery.com/#has_class\r\n\tfunction hasClass ( el, className ) {\r\n\t\tif ( el.classList ) {\r\n\t\t\tel.classList.contains(className);\r\n\t\t} else {\r\n\t\t\tnew RegExp('(^| )' + className + '( |$)', 'gi').test(el.className);\r\n\t\t}\r\n\t}\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/Window/scrollY#Notes\r\n\tfunction getPageOffset ( ) {\r\n\r\n\t\tvar supportPageOffset = window.pageXOffset !== undefined,\r\n\t\t\tisCSS1Compat = ((document.compatMode || \"\") === \"CSS1Compat\"),\r\n\t\t\tx = supportPageOffset ? window.pageXOffset : isCSS1Compat ? document.documentElement.scrollLeft : document.body.scrollLeft,\r\n\t\t\ty = supportPageOffset ? window.pageYOffset : isCSS1Compat ? document.documentElement.scrollTop : document.body.scrollTop;\r\n\r\n\t\treturn {\r\n\t\t\tx: x,\r\n\t\t\ty: y\r\n\t\t};\r\n\t}\r\n\r\n\t// Shorthand for stopPropagation so we don't have to create a dynamic method\r\n\tfunction stopPropagation ( e ) {\r\n\t\te.stopPropagation();\r\n\t}\r\n\r\n\t// todo\r\n\tfunction addCssPrefix(cssPrefix) {\r\n\t\treturn function(className) {\r\n\t\t\treturn cssPrefix + className;\r\n\t\t};\r\n\t}\r\n\r\n\r\n\tvar\r\n\t// Determine the events to bind. IE11 implements pointerEvents without\r\n\t// a prefix, which breaks compatibility with the IE10 implementation.\r\n\t/** @const */\r\n\tactions = window.navigator.pointerEnabled ? {\r\n\t\tstart: 'pointerdown',\r\n\t\tmove: 'pointermove',\r\n\t\tend: 'pointerup'\r\n\t} : window.navigator.msPointerEnabled ? {\r\n\t\tstart: 'MSPointerDown',\r\n\t\tmove: 'MSPointerMove',\r\n\t\tend: 'MSPointerUp'\r\n\t} : {\r\n\t\tstart: 'mousedown touchstart',\r\n\t\tmove: 'mousemove touchmove',\r\n\t\tend: 'mouseup touchend'\r\n\t},\r\n\tdefaultCssPrefix = 'noUi-';\r\n\r\n\r\n// Value calculation\r\n\r\n\t// Determine the size of a sub-range in relation to a full range.\r\n\tfunction subRangeRatio ( pa, pb ) {\r\n\t\treturn (100 / (pb - pa));\r\n\t}\r\n\r\n\t// (percentage) How many percent is this value of this range?\r\n\tfunction fromPercentage ( range, value ) {\r\n\t\treturn (value * 100) / ( range[1] - range[0] );\r\n\t}\r\n\r\n\t// (percentage) Where is this value on this range?\r\n\tfunction toPercentage ( range, value ) {\r\n\t\treturn fromPercentage( range, range[0] < 0 ?\r\n\t\t\tvalue + Math.abs(range[0]) :\r\n\t\t\t\tvalue - range[0] );\r\n\t}\r\n\r\n\t// (value) How much is this percentage on this range?\r\n\tfunction isPercentage ( range, value ) {\r\n\t\treturn ((value * ( range[1] - range[0] )) / 100) + range[0];\r\n\t}\r\n\r\n\r\n// Range conversion\r\n\r\n\tfunction getJ ( value, arr ) {\r\n\r\n\t\tvar j = 1;\r\n\r\n\t\twhile ( value >= arr[j] ){\r\n\t\t\tj += 1;\r\n\t\t}\r\n\r\n\t\treturn j;\r\n\t}\r\n\r\n\t// (percentage) Input a value, find where, on a scale of 0-100, it applies.\r\n\tfunction toStepping ( xVal, xPct, value ) {\r\n\r\n\t\tif ( value >= xVal.slice(-1)[0] ){\r\n\t\t\treturn 100;\r\n\t\t}\r\n\r\n\t\tvar j = getJ( value, xVal ), va, vb, pa, pb;\r\n\r\n\t\tva = xVal[j-1];\r\n\t\tvb = xVal[j];\r\n\t\tpa = xPct[j-1];\r\n\t\tpb = xPct[j];\r\n\r\n\t\treturn pa + (toPercentage([va, vb], value) / subRangeRatio (pa, pb));\r\n\t}\r\n\r\n\t// (value) Input a percentage, find where it is on the specified range.\r\n\tfunction fromStepping ( xVal, xPct, value ) {\r\n\r\n\t\t// There is no range group that fits 100\r\n\t\tif ( value >= 100 ){\r\n\t\t\treturn xVal.slice(-1)[0];\r\n\t\t}\r\n\r\n\t\tvar j = getJ( value, xPct ), va, vb, pa, pb;\r\n\r\n\t\tva = xVal[j-1];\r\n\t\tvb = xVal[j];\r\n\t\tpa = xPct[j-1];\r\n\t\tpb = xPct[j];\r\n\r\n\t\treturn isPercentage([va, vb], (value - pa) * subRangeRatio (pa, pb));\r\n\t}\r\n\r\n\t// (percentage) Get the step that applies at a certain value.\r\n\tfunction getStep ( xPct, xSteps, snap, value ) {\r\n\r\n\t\tif ( value === 100 ) {\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\tvar j = getJ( value, xPct ), a, b;\r\n\r\n\t\t// If 'snap' is set, steps are used as fixed points on the slider.\r\n\t\tif ( snap ) {\r\n\r\n\t\t\ta = xPct[j-1];\r\n\t\t\tb = xPct[j];\r\n\r\n\t\t\t// Find the closest position, a or b.\r\n\t\t\tif ((value - a) > ((b-a)/2)){\r\n\t\t\t\treturn b;\r\n\t\t\t}\r\n\r\n\t\t\treturn a;\r\n\t\t}\r\n\r\n\t\tif ( !xSteps[j-1] ){\r\n\t\t\treturn value;\r\n\t\t}\r\n\r\n\t\treturn xPct[j-1] + closest(\r\n\t\t\tvalue - xPct[j-1],\r\n\t\t\txSteps[j-1]\r\n\t\t);\r\n\t}\r\n\r\n\r\n// Entry parsing\r\n\r\n\tfunction handleEntryPoint ( index, value, that ) {\r\n\r\n\t\tvar percentage;\r\n\r\n\t\t// Wrap numerical input in an array.\r\n\t\tif ( typeof value === \"number\" ) {\r\n\t\t\tvalue = [value];\r\n\t\t}\r\n\r\n\t\t// Reject any invalid input, by testing whether value is an array.\r\n\t\tif ( Object.prototype.toString.call( value ) !== '[object Array]' ){\r\n\t\t\tthrow new Error(\"noUiSlider: 'range' contains invalid value.\");\r\n\t\t}\r\n\r\n\t\t// Covert min/max syntax to 0 and 100.\r\n\t\tif ( index === 'min' ) {\r\n\t\t\tpercentage = 0;\r\n\t\t} else if ( index === 'max' ) {\r\n\t\t\tpercentage = 100;\r\n\t\t} else {\r\n\t\t\tpercentage = parseFloat( index );\r\n\t\t}\r\n\r\n\t\t// Check for correct input.\r\n\t\tif ( !isNumeric( percentage ) || !isNumeric( value[0] ) ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'range' value isn't numeric.\");\r\n\t\t}\r\n\r\n\t\t// Store values.\r\n\t\tthat.xPct.push( percentage );\r\n\t\tthat.xVal.push( value[0] );\r\n\r\n\t\t// NaN will evaluate to false too, but to keep\r\n\t\t// logging clear, set step explicitly. Make sure\r\n\t\t// not to override the 'step' setting with false.\r\n\t\tif ( !percentage ) {\r\n\t\t\tif ( !isNaN( value[1] ) ) {\r\n\t\t\t\tthat.xSteps[0] = value[1];\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthat.xSteps.push( isNaN(value[1]) ? false : value[1] );\r\n\t\t}\r\n\t}\r\n\r\n\tfunction handleStepPoint ( i, n, that ) {\r\n\r\n\t\t// Ignore 'false' stepping.\r\n\t\tif ( !n ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// Factor to range ratio\r\n\t\tthat.xSteps[i] = fromPercentage([\r\n\t\t\t that.xVal[i]\r\n\t\t\t,that.xVal[i+1]\r\n\t\t], n) / subRangeRatio (\r\n\t\t\tthat.xPct[i],\r\n\t\t\tthat.xPct[i+1] );\r\n\t}\r\n\r\n\r\n// Interface\r\n\r\n\t// The interface to Spectrum handles all direction-based\r\n\t// conversions, so the above values are unaware.\r\n\r\n\tfunction Spectrum ( entry, snap, direction, singleStep ) {\r\n\r\n\t\tthis.xPct = [];\r\n\t\tthis.xVal = [];\r\n\t\tthis.xSteps = [ singleStep || false ];\r\n\t\tthis.xNumSteps = [ false ];\r\n\r\n\t\tthis.snap = snap;\r\n\t\tthis.direction = direction;\r\n\r\n\t\tvar index, ordered = [ /* [0, 'min'], [1, '50%'], [2, 'max'] */ ];\r\n\r\n\t\t// Map the object keys to an array.\r\n\t\tfor ( index in entry ) {\r\n\t\t\tif ( entry.hasOwnProperty(index) ) {\r\n\t\t\t\tordered.push([entry[index], index]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Sort all entries by value (numeric sort).\r\n\t\tif ( ordered.length && typeof ordered[0][0] === \"object\" ) {\r\n\t\t\tordered.sort(function(a, b) { return a[0][0] - b[0][0]; });\r\n\t\t} else {\r\n\t\t\tordered.sort(function(a, b) { return a[0] - b[0]; });\r\n\t\t}\r\n\r\n\r\n\t\t// Convert all entries to subranges.\r\n\t\tfor ( index = 0; index < ordered.length; index++ ) {\r\n\t\t\thandleEntryPoint(ordered[index][1], ordered[index][0], this);\r\n\t\t}\r\n\r\n\t\t// Store the actual step values.\r\n\t\t// xSteps is sorted in the same order as xPct and xVal.\r\n\t\tthis.xNumSteps = this.xSteps.slice(0);\r\n\r\n\t\t// Convert all numeric steps to the percentage of the subrange they represent.\r\n\t\tfor ( index = 0; index < this.xNumSteps.length; index++ ) {\r\n\t\t\thandleStepPoint(index, this.xNumSteps[index], this);\r\n\t\t}\r\n\t}\r\n\r\n\tSpectrum.prototype.getMargin = function ( value ) {\r\n\t\treturn this.xPct.length === 2 ? fromPercentage(this.xVal, value) : false;\r\n\t};\r\n\r\n\tSpectrum.prototype.toStepping = function ( value ) {\r\n\r\n\t\tvalue = toStepping( this.xVal, this.xPct, value );\r\n\r\n\t\t// Invert the value if this is a right-to-left slider.\r\n\t\tif ( this.direction ) {\r\n\t\t\tvalue = 100 - value;\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t};\r\n\r\n\tSpectrum.prototype.fromStepping = function ( value ) {\r\n\r\n\t\t// Invert the value if this is a right-to-left slider.\r\n\t\tif ( this.direction ) {\r\n\t\t\tvalue = 100 - value;\r\n\t\t}\r\n\r\n\t\treturn accurateNumber(fromStepping( this.xVal, this.xPct, value ));\r\n\t};\r\n\r\n\tSpectrum.prototype.getStep = function ( value ) {\r\n\r\n\t\t// Find the proper step for rtl sliders by search in inverse direction.\r\n\t\t// Fixes issue #262.\r\n\t\tif ( this.direction ) {\r\n\t\t\tvalue = 100 - value;\r\n\t\t}\r\n\r\n\t\tvalue = getStep(this.xPct, this.xSteps, this.snap, value );\r\n\r\n\t\tif ( this.direction ) {\r\n\t\t\tvalue = 100 - value;\r\n\t\t}\r\n\r\n\t\treturn value;\r\n\t};\r\n\r\n\tSpectrum.prototype.getApplicableStep = function ( value ) {\r\n\r\n\t\t// If the value is 100%, return the negative step twice.\r\n\t\tvar j = getJ(value, this.xPct), offset = value === 100 ? 2 : 1;\r\n\t\treturn [this.xNumSteps[j-2], this.xVal[j-offset], this.xNumSteps[j-offset]];\r\n\t};\r\n\r\n\t// Outside testing\r\n\tSpectrum.prototype.convert = function ( value ) {\r\n\t\treturn this.getStep(this.toStepping(value));\r\n\t};\r\n\r\n/*\tEvery input option is tested and parsed. This'll prevent\r\n\tendless validation in internal methods. These tests are\r\n\tstructured with an item for every option available. An\r\n\toption can be marked as required by setting the 'r' flag.\r\n\tThe testing function is provided with three arguments:\r\n\t\t- The provided value for the option;\r\n\t\t- A reference to the options object;\r\n\t\t- The name for the option;\r\n\r\n\tThe testing function returns false when an error is detected,\r\n\tor true when everything is OK. It can also modify the option\r\n\tobject, to make sure all values can be correctly looped elsewhere. */\r\n\r\n\tvar defaultFormatter = { 'to': function( value ){\r\n\t\treturn value !== undefined && value.toFixed(2);\r\n\t}, 'from': Number };\r\n\r\n\tfunction testStep ( parsed, entry ) {\r\n\r\n\t\tif ( !isNumeric( entry ) ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'step' is not numeric.\");\r\n\t\t}\r\n\r\n\t\t// The step option can still be used to set stepping\r\n\t\t// for linear sliders. Overwritten if set in 'range'.\r\n\t\tparsed.singleStep = entry;\r\n\t}\r\n\r\n\tfunction testRange ( parsed, entry ) {\r\n\r\n\t\t// Filter incorrect input.\r\n\t\tif ( typeof entry !== 'object' || Array.isArray(entry) ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'range' is not an object.\");\r\n\t\t}\r\n\r\n\t\t// Catch missing start or end.\r\n\t\tif ( entry.min === undefined || entry.max === undefined ) {\r\n\t\t\tthrow new Error(\"noUiSlider: Missing 'min' or 'max' in 'range'.\");\r\n\t\t}\r\n\r\n\t\t// Catch equal start or end.\r\n\t\tif ( entry.min === entry.max ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'range' 'min' and 'max' cannot be equal.\");\r\n\t\t}\r\n\r\n\t\tparsed.spectrum = new Spectrum(entry, parsed.snap, parsed.dir, parsed.singleStep);\r\n\t}\r\n\r\n\tfunction testStart ( parsed, entry ) {\r\n\r\n\t\tentry = asArray(entry);\r\n\r\n\t\t// Validate input. Values aren't tested, as the public .val method\r\n\t\t// will always provide a valid location.\r\n\t\tif ( !Array.isArray( entry ) || !entry.length || entry.length > 2 ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'start' option is incorrect.\");\r\n\t\t}\r\n\r\n\t\t// Store the number of handles.\r\n\t\tparsed.handles = entry.length;\r\n\r\n\t\t// When the slider is initialized, the .val method will\r\n\t\t// be called with the start options.\r\n\t\tparsed.start = entry;\r\n\t}\r\n\r\n\tfunction testSnap ( parsed, entry ) {\r\n\r\n\t\t// Enforce 100% stepping within subranges.\r\n\t\tparsed.snap = entry;\r\n\r\n\t\tif ( typeof entry !== 'boolean' ){\r\n\t\t\tthrow new Error(\"noUiSlider: 'snap' option must be a boolean.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testAnimate ( parsed, entry ) {\r\n\r\n\t\t// Enforce 100% stepping within subranges.\r\n\t\tparsed.animate = entry;\r\n\r\n\t\tif ( typeof entry !== 'boolean' ){\r\n\t\t\tthrow new Error(\"noUiSlider: 'animate' option must be a boolean.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testConnect ( parsed, entry ) {\r\n\r\n\t\tif ( entry === 'lower' && parsed.handles === 1 ) {\r\n\t\t\tparsed.connect = 1;\r\n\t\t} else if ( entry === 'upper' && parsed.handles === 1 ) {\r\n\t\t\tparsed.connect = 2;\r\n\t\t} else if ( entry === true && parsed.handles === 2 ) {\r\n\t\t\tparsed.connect = 3;\r\n\t\t} else if ( entry === false ) {\r\n\t\t\tparsed.connect = 0;\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"noUiSlider: 'connect' option doesn't match handle count.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testOrientation ( parsed, entry ) {\r\n\r\n\t\t// Set orientation to an a numerical value for easy\r\n\t\t// array selection.\r\n\t\tswitch ( entry ){\r\n\t\t  case 'horizontal':\r\n\t\t\tparsed.ort = 0;\r\n\t\t\tbreak;\r\n\t\t  case 'vertical':\r\n\t\t\tparsed.ort = 1;\r\n\t\t\tbreak;\r\n\t\t  default:\r\n\t\t\tthrow new Error(\"noUiSlider: 'orientation' option is invalid.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testMargin ( parsed, entry ) {\r\n\r\n\t\tif ( !isNumeric(entry) ){\r\n\t\t\tthrow new Error(\"noUiSlider: 'margin' option must be numeric.\");\r\n\t\t}\r\n\r\n\t\tparsed.margin = parsed.spectrum.getMargin(entry);\r\n\r\n\t\tif ( !parsed.margin ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'margin' option is only supported on linear sliders.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testLimit ( parsed, entry ) {\r\n\r\n\t\tif ( !isNumeric(entry) ){\r\n\t\t\tthrow new Error(\"noUiSlider: 'limit' option must be numeric.\");\r\n\t\t}\r\n\r\n\t\tparsed.limit = parsed.spectrum.getMargin(entry);\r\n\r\n\t\tif ( !parsed.limit ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'limit' option is only supported on linear sliders.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testDirection ( parsed, entry ) {\r\n\r\n\t\t// Set direction as a numerical value for easy parsing.\r\n\t\t// Invert connection for RTL sliders, so that the proper\r\n\t\t// handles get the connect/background classes.\r\n\t\tswitch ( entry ) {\r\n\t\t  case 'ltr':\r\n\t\t\tparsed.dir = 0;\r\n\t\t\tbreak;\r\n\t\t  case 'rtl':\r\n\t\t\tparsed.dir = 1;\r\n\t\t\tparsed.connect = [0,2,1,3][parsed.connect];\r\n\t\t\tbreak;\r\n\t\t  default:\r\n\t\t\tthrow new Error(\"noUiSlider: 'direction' option was not recognized.\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testBehaviour ( parsed, entry ) {\r\n\r\n\t\t// Make sure the input is a string.\r\n\t\tif ( typeof entry !== 'string' ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'behaviour' must be a string containing options.\");\r\n\t\t}\r\n\r\n\t\t// Check if the string contains any keywords.\r\n\t\t// None are required.\r\n\t\tvar tap = entry.indexOf('tap') >= 0,\r\n\t\t\tdrag = entry.indexOf('drag') >= 0,\r\n\t\t\tfixed = entry.indexOf('fixed') >= 0,\r\n\t\t\tsnap = entry.indexOf('snap') >= 0,\r\n\t\t\thover = entry.indexOf('hover') >= 0;\r\n\r\n\t\t// Fix #472\r\n\t\tif ( drag && !parsed.connect ) {\r\n\t\t\tthrow new Error(\"noUiSlider: 'drag' behaviour must be used with 'connect': true.\");\r\n\t\t}\r\n\r\n\t\tparsed.events = {\r\n\t\t\ttap: tap || snap,\r\n\t\t\tdrag: drag,\r\n\t\t\tfixed: fixed,\r\n\t\t\tsnap: snap,\r\n\t\t\thover: hover\r\n\t\t};\r\n\t}\r\n\r\n\tfunction testTooltips ( parsed, entry ) {\r\n\r\n\t\tvar i;\r\n\r\n\t\tif ( entry === false ) {\r\n\t\t\treturn;\r\n\t\t} else if ( entry === true ) {\r\n\r\n\t\t\tparsed.tooltips = [];\r\n\r\n\t\t\tfor ( i = 0; i < parsed.handles; i++ ) {\r\n\t\t\t\tparsed.tooltips.push(true);\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tparsed.tooltips = asArray(entry);\r\n\r\n\t\t\tif ( parsed.tooltips.length !== parsed.handles ) {\r\n\t\t\t\tthrow new Error(\"noUiSlider: must pass a formatter for all handles.\");\r\n\t\t\t}\r\n\r\n\t\t\tparsed.tooltips.forEach(function(formatter){\r\n\t\t\t\tif ( typeof formatter !== 'boolean' && (typeof formatter !== 'object' || typeof formatter.to !== 'function') ) {\r\n\t\t\t\t\tthrow new Error(\"noUiSlider: 'tooltips' must be passed a formatter or 'false'.\");\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\tfunction testFormat ( parsed, entry ) {\r\n\r\n\t\tparsed.format = entry;\r\n\r\n\t\t// Any object with a to and from method is supported.\r\n\t\tif ( typeof entry.to === 'function' && typeof entry.from === 'function' ) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tthrow new Error( \"noUiSlider: 'format' requires 'to' and 'from' methods.\");\r\n\t}\r\n\r\n\tfunction testCssPrefix ( parsed, entry ) {\r\n\r\n\t\tif ( entry !== undefined && typeof entry !== 'string' ) {\r\n\t\t\tthrow new Error( \"noUiSlider: 'cssPrefix' must be a string.\");\r\n\t\t}\r\n\r\n\t\tparsed.cssPrefix = entry;\r\n\t}\r\n\r\n\t// Test all developer settings and parse to assumption-safe values.\r\n\tfunction testOptions ( options ) {\r\n\r\n\t\t// To prove a fix for #537, freeze options here.\r\n\t\t// If the object is modified, an error will be thrown.\r\n\t\t// Object.freeze(options);\r\n\r\n\t\tvar parsed = {\r\n\t\t\tmargin: 0,\r\n\t\t\tlimit: 0,\r\n\t\t\tanimate: true,\r\n\t\t\tformat: defaultFormatter\r\n\t\t}, tests;\r\n\r\n\t\t// Tests are executed in the order they are presented here.\r\n\t\ttests = {\r\n\t\t\t'step': { r: false, t: testStep },\r\n\t\t\t'start': { r: true, t: testStart },\r\n\t\t\t'connect': { r: true, t: testConnect },\r\n\t\t\t'direction': { r: true, t: testDirection },\r\n\t\t\t'snap': { r: false, t: testSnap },\r\n\t\t\t'animate': { r: false, t: testAnimate },\r\n\t\t\t'range': { r: true, t: testRange },\r\n\t\t\t'orientation': { r: false, t: testOrientation },\r\n\t\t\t'margin': { r: false, t: testMargin },\r\n\t\t\t'limit': { r: false, t: testLimit },\r\n\t\t\t'behaviour': { r: true, t: testBehaviour },\r\n\t\t\t'format': { r: false, t: testFormat },\r\n\t\t\t'tooltips': { r: false, t: testTooltips },\r\n\t\t\t'cssPrefix': { r: false, t: testCssPrefix }\r\n\t\t};\r\n\r\n\t\tvar defaults = {\r\n\t\t\t'connect': false,\r\n\t\t\t'direction': 'ltr',\r\n\t\t\t'behaviour': 'tap',\r\n\t\t\t'orientation': 'horizontal'\r\n\t\t};\r\n\r\n\t\t// Run all options through a testing mechanism to ensure correct\r\n\t\t// input. It should be noted that options might get modified to\r\n\t\t// be handled properly. E.g. wrapping integers in arrays.\r\n\t\tObject.keys(tests).forEach(function( name ){\r\n\r\n\t\t\t// If the option isn't set, but it is required, throw an error.\r\n\t\t\tif ( options[name] === undefined && defaults[name] === undefined ) {\r\n\r\n\t\t\t\tif ( tests[name].r ) {\r\n\t\t\t\t\tthrow new Error(\"noUiSlider: '\" + name + \"' is required.\");\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\ttests[name].t( parsed, options[name] === undefined ? defaults[name] : options[name] );\r\n\t\t});\r\n\r\n\t\t// Forward pips options\r\n\t\tparsed.pips = options.pips;\r\n\r\n\t\t// Pre-define the styles.\r\n\t\tparsed.style = parsed.ort ? 'top' : 'left';\r\n\r\n\t\treturn parsed;\r\n\t}\r\n\r\n\r\nfunction closure ( target, options ){\r\n\r\n\t// All variables local to 'closure' are prefixed with 'scope_'\r\n\tvar scope_Target = target,\r\n\t\tscope_Locations = [-1, -1],\r\n\t\tscope_Base,\r\n\t\tscope_Handles,\r\n\t\tscope_Spectrum = options.spectrum,\r\n\t\tscope_Values = [],\r\n\t\tscope_Events = {},\r\n\t\tscope_Self;\r\n\r\n  var cssClasses = [\r\n    /*  0 */  'target'\r\n    /*  1 */ ,'base'\r\n    /*  2 */ ,'origin'\r\n    /*  3 */ ,'handle'\r\n    /*  4 */ ,'horizontal'\r\n    /*  5 */ ,'vertical'\r\n    /*  6 */ ,'background'\r\n    /*  7 */ ,'connect'\r\n    /*  8 */ ,'ltr'\r\n    /*  9 */ ,'rtl'\r\n    /* 10 */ ,'draggable'\r\n    /* 11 */ ,''\r\n    /* 12 */ ,'state-drag'\r\n    /* 13 */ ,''\r\n    /* 14 */ ,'state-tap'\r\n    /* 15 */ ,'active'\r\n    /* 16 */ ,''\r\n    /* 17 */ ,'stacking'\r\n    /* 18 */ ,'tooltip'\r\n    /* 19 */ ,''\r\n    /* 20 */ ,'pips'\r\n    /* 21 */ ,'marker'\r\n    /* 22 */ ,'value'\r\n  ].map(addCssPrefix(options.cssPrefix || defaultCssPrefix));\r\n\r\n\r\n\t// Delimit proposed values for handle positions.\r\n\tfunction getPositions ( a, b, delimit ) {\r\n\r\n\t\t// Add movement to current position.\r\n\t\tvar c = a + b[0], d = a + b[1];\r\n\r\n\t\t// Only alter the other position on drag,\r\n\t\t// not on standard sliding.\r\n\t\tif ( delimit ) {\r\n\t\t\tif ( c < 0 ) {\r\n\t\t\t\td += Math.abs(c);\r\n\t\t\t}\r\n\t\t\tif ( d > 100 ) {\r\n\t\t\t\tc -= ( d - 100 );\r\n\t\t\t}\r\n\r\n\t\t\t// Limit values to 0 and 100.\r\n\t\t\treturn [limit(c), limit(d)];\r\n\t\t}\r\n\r\n\t\treturn [c,d];\r\n\t}\r\n\r\n\t// Provide a clean event with standardized offset values.\r\n\tfunction fixEvent ( e, pageOffset ) {\r\n\r\n\t\t// Prevent scrolling and panning on touch events, while\r\n\t\t// attempting to slide. The tap event also depends on this.\r\n\t\te.preventDefault();\r\n\r\n\t\t// Filter the event to register the type, which can be\r\n\t\t// touch, mouse or pointer. Offset changes need to be\r\n\t\t// made on an event specific basis.\r\n\t\tvar touch = e.type.indexOf('touch') === 0,\r\n\t\t\tmouse = e.type.indexOf('mouse') === 0,\r\n\t\t\tpointer = e.type.indexOf('pointer') === 0,\r\n\t\t\tx,y, event = e;\r\n\r\n\t\t// IE10 implemented pointer events with a prefix;\r\n\t\tif ( e.type.indexOf('MSPointer') === 0 ) {\r\n\t\t\tpointer = true;\r\n\t\t}\r\n\r\n\t\tif ( touch ) {\r\n\t\t\t// noUiSlider supports one movement at a time,\r\n\t\t\t// so we can select the first 'changedTouch'.\r\n\t\t\tx = e.changedTouches[0].pageX;\r\n\t\t\ty = e.changedTouches[0].pageY;\r\n\t\t}\r\n\r\n\t\tpageOffset = pageOffset || getPageOffset();\r\n\r\n\t\tif ( mouse || pointer ) {\r\n\t\t\tx = e.clientX + pageOffset.x;\r\n\t\t\ty = e.clientY + pageOffset.y;\r\n\t\t}\r\n\r\n\t\tevent.pageOffset = pageOffset;\r\n\t\tevent.points = [x, y];\r\n\t\tevent.cursor = mouse || pointer; // Fix #435\r\n\r\n\t\treturn event;\r\n\t}\r\n\r\n\t// Append a handle to the base.\r\n\tfunction addHandle ( direction, index ) {\r\n\r\n\t\tvar origin = document.createElement('div'),\r\n\t\t\thandle = document.createElement('div'),\r\n\t\t\tadditions = [ '-lower', '-upper' ];\r\n\r\n\t\tif ( direction ) {\r\n\t\t\tadditions.reverse();\r\n\t\t}\r\n\r\n\t\taddClass(handle, cssClasses[3]);\r\n\t\taddClass(handle, cssClasses[3] + additions[index]);\r\n\r\n\t\taddClass(origin, cssClasses[2]);\r\n\t\torigin.appendChild(handle);\r\n\r\n\t\treturn origin;\r\n\t}\r\n\r\n\t// Add the proper connection classes.\r\n\tfunction addConnection ( connect, target, handles ) {\r\n\r\n\t\t// Apply the required connection classes to the elements\r\n\t\t// that need them. Some classes are made up for several\r\n\t\t// segments listed in the class list, to allow easy\r\n\t\t// renaming and provide a minor compression benefit.\r\n\t\tswitch ( connect ) {\r\n\t\t\tcase 1:\taddClass(target, cssClasses[7]);\r\n\t\t\t\t\taddClass(handles[0], cssClasses[6]);\r\n\t\t\t\t\tbreak;\r\n\t\t\tcase 3: addClass(handles[1], cssClasses[6]);\r\n\t\t\t\t\t/* falls through */\r\n\t\t\tcase 2: addClass(handles[0], cssClasses[7]);\r\n\t\t\t\t\t/* falls through */\r\n\t\t\tcase 0: addClass(target, cssClasses[6]);\r\n\t\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\r\n\t// Add handles to the slider base.\r\n\tfunction addHandles ( nrHandles, direction, base ) {\r\n\r\n\t\tvar index, handles = [];\r\n\r\n\t\t// Append handles.\r\n\t\tfor ( index = 0; index < nrHandles; index += 1 ) {\r\n\r\n\t\t\t// Keep a list of all added handles.\r\n\t\t\thandles.push( base.appendChild(addHandle( direction, index )) );\r\n\t\t}\r\n\r\n\t\treturn handles;\r\n\t}\r\n\r\n\t// Initialize a single slider.\r\n\tfunction addSlider ( direction, orientation, target ) {\r\n\r\n\t\t// Apply classes and data to the target.\r\n\t\taddClass(target, cssClasses[0]);\r\n\t\taddClass(target, cssClasses[8 + direction]);\r\n\t\taddClass(target, cssClasses[4 + orientation]);\r\n\r\n\t\tvar div = document.createElement('div');\r\n\t\taddClass(div, cssClasses[1]);\r\n\t\ttarget.appendChild(div);\r\n\t\treturn div;\r\n\t}\r\n\r\n\r\n\tfunction addTooltip ( handle, index ) {\r\n\r\n\t\tif ( !options.tooltips[index] ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\tvar element = document.createElement('div');\r\n\t\telement.className = cssClasses[18];\r\n\t\treturn handle.firstChild.appendChild(element);\r\n\t}\r\n\r\n\t// The tooltips option is a shorthand for using the 'update' event.\r\n\tfunction tooltips ( ) {\r\n\r\n\t\tif ( options.dir ) {\r\n\t\t\toptions.tooltips.reverse();\r\n\t\t}\r\n\r\n\t\t// Tooltips are added with options.tooltips in original order.\r\n\t\tvar tips = scope_Handles.map(addTooltip);\r\n\r\n\t\tif ( options.dir ) {\r\n\t\t\ttips.reverse();\r\n\t\t\toptions.tooltips.reverse();\r\n\t\t}\r\n\r\n\t\tbindEvent('update', function(f, o, r) {\r\n\t\t\tif ( tips[o] ) {\r\n\t\t\t\ttips[o].innerHTML = options.tooltips[o] === true ? f[o] : options.tooltips[o].to(r[o]);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\r\n\tfunction getGroup ( mode, values, stepped ) {\r\n\r\n\t\t// Use the range.\r\n\t\tif ( mode === 'range' || mode === 'steps' ) {\r\n\t\t\treturn scope_Spectrum.xVal;\r\n\t\t}\r\n\r\n\t\tif ( mode === 'count' ) {\r\n\r\n\t\t\t// Divide 0 - 100 in 'count' parts.\r\n\t\t\tvar spread = ( 100 / (values-1) ), v, i = 0;\r\n\t\t\tvalues = [];\r\n\r\n\t\t\t// List these parts and have them handled as 'positions'.\r\n\t\t\twhile ((v=i++*spread) <= 100 ) {\r\n\t\t\t\tvalues.push(v);\r\n\t\t\t}\r\n\r\n\t\t\tmode = 'positions';\r\n\t\t}\r\n\r\n\t\tif ( mode === 'positions' ) {\r\n\r\n\t\t\t// Map all percentages to on-range values.\r\n\t\t\treturn values.map(function( value ){\r\n\t\t\t\treturn scope_Spectrum.fromStepping( stepped ? scope_Spectrum.getStep( value ) : value );\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tif ( mode === 'values' ) {\r\n\r\n\t\t\t// If the value must be stepped, it needs to be converted to a percentage first.\r\n\t\t\tif ( stepped ) {\r\n\r\n\t\t\t\treturn values.map(function( value ){\r\n\r\n\t\t\t\t\t// Convert to percentage, apply step, return to value.\r\n\t\t\t\t\treturn scope_Spectrum.fromStepping( scope_Spectrum.getStep( scope_Spectrum.toStepping( value ) ) );\r\n\t\t\t\t});\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Otherwise, we can simply use the values.\r\n\t\t\treturn values;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction generateSpread ( density, mode, group ) {\r\n\r\n\t\tfunction safeIncrement(value, increment) {\r\n\t\t\t// Avoid floating point variance by dropping the smallest decimal places.\r\n\t\t\treturn (value + increment).toFixed(7) / 1;\r\n\t\t}\r\n\r\n\t\tvar originalSpectrumDirection = scope_Spectrum.direction,\r\n\t\t\tindexes = {},\r\n\t\t\tfirstInRange = scope_Spectrum.xVal[0],\r\n\t\t\tlastInRange = scope_Spectrum.xVal[scope_Spectrum.xVal.length-1],\r\n\t\t\tignoreFirst = false,\r\n\t\t\tignoreLast = false,\r\n\t\t\tprevPct = 0;\r\n\r\n\t\t// This function loops the spectrum in an ltr linear fashion,\r\n\t\t// while the toStepping method is direction aware. Trick it into\r\n\t\t// believing it is ltr.\r\n\t\tscope_Spectrum.direction = 0;\r\n\r\n\t\t// Create a copy of the group, sort it and filter away all duplicates.\r\n\t\tgroup = unique(group.slice().sort(function(a, b){ return a - b; }));\r\n\r\n\t\t// Make sure the range starts with the first element.\r\n\t\tif ( group[0] !== firstInRange ) {\r\n\t\t\tgroup.unshift(firstInRange);\r\n\t\t\tignoreFirst = true;\r\n\t\t}\r\n\r\n\t\t// Likewise for the last one.\r\n\t\tif ( group[group.length - 1] !== lastInRange ) {\r\n\t\t\tgroup.push(lastInRange);\r\n\t\t\tignoreLast = true;\r\n\t\t}\r\n\r\n\t\tgroup.forEach(function ( current, index ) {\r\n\r\n\t\t\t// Get the current step and the lower + upper positions.\r\n\t\t\tvar step, i, q,\r\n\t\t\t\tlow = current,\r\n\t\t\t\thigh = group[index+1],\r\n\t\t\t\tnewPct, pctDifference, pctPos, type,\r\n\t\t\t\tsteps, realSteps, stepsize;\r\n\r\n\t\t\t// When using 'steps' mode, use the provided steps.\r\n\t\t\t// Otherwise, we'll step on to the next subrange.\r\n\t\t\tif ( mode === 'steps' ) {\r\n\t\t\t\tstep = scope_Spectrum.xNumSteps[ index ];\r\n\t\t\t}\r\n\r\n\t\t\t// Default to a 'full' step.\r\n\t\t\tif ( !step ) {\r\n\t\t\t\tstep = high-low;\r\n\t\t\t}\r\n\r\n\t\t\t// Low can be 0, so test for false. If high is undefined,\r\n\t\t\t// we are at the last subrange. Index 0 is already handled.\r\n\t\t\tif ( low === false || high === undefined ) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Find all steps in the subrange.\r\n\t\t\tfor ( i = low; i <= high; i = safeIncrement(i, step) ) {\r\n\r\n\t\t\t\t// Get the percentage value for the current step,\r\n\t\t\t\t// calculate the size for the subrange.\r\n\t\t\t\tnewPct = scope_Spectrum.toStepping( i );\r\n\t\t\t\tpctDifference = newPct - prevPct;\r\n\r\n\t\t\t\tsteps = pctDifference / density;\r\n\t\t\t\trealSteps = Math.round(steps);\r\n\r\n\t\t\t\t// This ratio represents the ammount of percentage-space a point indicates.\r\n\t\t\t\t// For a density 1 the points/percentage = 1. For density 2, that percentage needs to be re-devided.\r\n\t\t\t\t// Round the percentage offset to an even number, then divide by two\r\n\t\t\t\t// to spread the offset on both sides of the range.\r\n\t\t\t\tstepsize = pctDifference/realSteps;\r\n\r\n\t\t\t\t// Divide all points evenly, adding the correct number to this subrange.\r\n\t\t\t\t// Run up to <= so that 100% gets a point, event if ignoreLast is set.\r\n\t\t\t\tfor ( q = 1; q <= realSteps; q += 1 ) {\r\n\r\n\t\t\t\t\t// The ratio between the rounded value and the actual size might be ~1% off.\r\n\t\t\t\t\t// Correct the percentage offset by the number of points\r\n\t\t\t\t\t// per subrange. density = 1 will result in 100 points on the\r\n\t\t\t\t\t// full range, 2 for 50, 4 for 25, etc.\r\n\t\t\t\t\tpctPos = prevPct + ( q * stepsize );\r\n\t\t\t\t\tindexes[pctPos.toFixed(5)] = ['x', 0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Determine the point type.\r\n\t\t\t\ttype = (group.indexOf(i) > -1) ? 1 : ( mode === 'steps' ? 2 : 0 );\r\n\r\n\t\t\t\t// Enforce the 'ignoreFirst' option by overwriting the type for 0.\r\n\t\t\t\tif ( !index && ignoreFirst ) {\r\n\t\t\t\t\ttype = 0;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( !(i === high && ignoreLast)) {\r\n\t\t\t\t\t// Mark the 'type' of this point. 0 = plain, 1 = real value, 2 = step value.\r\n\t\t\t\t\tindexes[newPct.toFixed(5)] = [i, type];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Update the percentage count.\r\n\t\t\t\tprevPct = newPct;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\t// Reset the spectrum.\r\n\t\tscope_Spectrum.direction = originalSpectrumDirection;\r\n\r\n\t\treturn indexes;\r\n\t}\r\n\r\n\tfunction addMarking ( spread, filterFunc, formatter ) {\r\n\r\n\t\tvar style = ['horizontal', 'vertical'][options.ort],\r\n\t\t\telement = document.createElement('div');\r\n\r\n\t\taddClass(element, cssClasses[20]);\r\n\t\taddClass(element, cssClasses[20] + '-' + style);\r\n\r\n\t\tfunction getSize( type ){\r\n\t\t\treturn [ '-normal', '-large', '-sub' ][type];\r\n\t\t}\r\n\r\n\t\tfunction getTags( offset, source, values ) {\r\n\t\t\treturn 'class=\"' + source + ' ' +\r\n\t\t\t\tsource + '-' + style + ' ' +\r\n\t\t\t\tsource + getSize(values[1]) +\r\n\t\t\t\t'\" style=\"' + options.style + ': ' + offset + '%\"';\r\n\t\t}\r\n\r\n\t\tfunction addSpread ( offset, values ){\r\n\r\n\t\t\tif ( scope_Spectrum.direction ) {\r\n\t\t\t\toffset = 100 - offset;\r\n\t\t\t}\r\n\r\n\t\t\t// Apply the filter function, if it is set.\r\n\t\t\tvalues[1] = (values[1] && filterFunc) ? filterFunc(values[0], values[1]) : values[1];\r\n\r\n\t\t\t// Add a marker for every point\r\n\t\t\telement.innerHTML += '<div ' + getTags(offset, cssClasses[21], values) + '></div>';\r\n\r\n\t\t\t// Values are only appended for points marked '1' or '2'.\r\n\t\t\tif ( values[1] ) {\r\n\t\t\t\telement.innerHTML += '<div '+getTags(offset, cssClasses[22], values)+'>' + formatter.to(values[0]) + '</div>';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Append all points.\r\n\t\tObject.keys(spread).forEach(function(a){\r\n\t\t\taddSpread(a, spread[a]);\r\n\t\t});\r\n\r\n\t\treturn element;\r\n\t}\r\n\r\n\tfunction pips ( grid ) {\r\n\r\n\tvar mode = grid.mode,\r\n\t\tdensity = grid.density || 1,\r\n\t\tfilter = grid.filter || false,\r\n\t\tvalues = grid.values || false,\r\n\t\tstepped = grid.stepped || false,\r\n\t\tgroup = getGroup( mode, values, stepped ),\r\n\t\tspread = generateSpread( density, mode, group ),\r\n\t\tformat = grid.format || {\r\n\t\t\tto: Math.round\r\n\t\t};\r\n\r\n\t\treturn scope_Target.appendChild(addMarking(\r\n\t\t\tspread,\r\n\t\t\tfilter,\r\n\t\t\tformat\r\n\t\t));\r\n\t}\r\n\r\n\r\n\t// Shorthand for base dimensions.\r\n\tfunction baseSize ( ) {\r\n\t\treturn scope_Base['offset' + ['Width', 'Height'][options.ort]];\r\n\t}\r\n\r\n\t// External event handling\r\n\tfunction fireEvent ( event, handleNumber, tap ) {\r\n\r\n\t\tif ( handleNumber !== undefined && options.handles !== 1 ) {\r\n\t\t\thandleNumber = Math.abs(handleNumber - options.dir);\r\n\t\t}\r\n\r\n\t\tObject.keys(scope_Events).forEach(function( targetEvent ) {\r\n\r\n\t\t\tvar eventType = targetEvent.split('.')[0];\r\n\r\n\t\t\tif ( event === eventType ) {\r\n\t\t\t\tscope_Events[targetEvent].forEach(function( callback ) {\r\n\t\t\t\t\t// .reverse is in place\r\n\t\t\t\t\t// Return values as array, so arg_1[arg_2] is always valid.\r\n\t\t\t\t\tcallback.call(scope_Self, asArray(valueGet()), handleNumber, asArray(inSliderOrder(Array.prototype.slice.call(scope_Values))), tap || false);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Returns the input array, respecting the slider direction configuration.\r\n\tfunction inSliderOrder ( values ) {\r\n\r\n\t\t// If only one handle is used, return a single value.\r\n\t\tif ( values.length === 1 ){\r\n\t\t\treturn values[0];\r\n\t\t}\r\n\r\n\t\tif ( options.dir ) {\r\n\t\t\treturn values.reverse();\r\n\t\t}\r\n\r\n\t\treturn values;\r\n\t}\r\n\r\n\r\n\t// Handler for attaching events trough a proxy.\r\n\tfunction attach ( events, element, callback, data ) {\r\n\r\n\t\t// This function can be used to 'filter' events to the slider.\r\n\t\t// element is a node, not a nodeList\r\n\r\n\t\tvar method = function ( e ){\r\n\r\n\t\t\tif ( scope_Target.hasAttribute('disabled') ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Stop if an active 'tap' transition is taking place.\r\n\t\t\tif ( hasClass(scope_Target, cssClasses[14]) ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\te = fixEvent(e, data.pageOffset);\r\n\r\n\t\t\t// Ignore right or middle clicks on start #454\r\n\t\t\tif ( events === actions.start && e.buttons !== undefined && e.buttons > 1 ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Ignore right or middle clicks on start #454\r\n\t\t\tif ( data.hover && e.buttons ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\te.calcPoint = e.points[ options.ort ];\r\n\r\n\t\t\t// Call the event handler with the event [ and additional data ].\r\n\t\t\tcallback ( e, data );\r\n\r\n\t\t}, methods = [];\r\n\r\n\t\t// Bind a closure on the target for every event type.\r\n\t\tevents.split(' ').forEach(function( eventName ){\r\n\t\t\telement.addEventListener(eventName, method, false);\r\n\t\t\tmethods.push([eventName, method]);\r\n\t\t});\r\n\r\n\t\treturn methods;\r\n\t}\r\n\r\n\t// Handle movement on document for handle and range drag.\r\n\tfunction move ( event, data ) {\r\n\r\n\t\t// Fix #498\r\n\t\t// Check value of .buttons in 'start' to work around a bug in IE10 mobile (data.buttonsProperty).\r\n\t\t// https://connect.microsoft.com/IE/feedback/details/927005/mobile-ie10-windows-phone-buttons-property-of-pointermove-event-always-zero\r\n\t\t// IE9 has .buttons and .which zero on mousemove.\r\n\t\t// Firefox breaks the spec MDN defines.\r\n\t\tif ( navigator.appVersion.indexOf(\"MSIE 9\") === -1 && event.buttons === 0 && data.buttonsProperty !== 0 ) {\r\n\t\t\treturn end(event, data);\r\n\t\t}\r\n\r\n\t\tvar handles = data.handles || scope_Handles, positions, state = false,\r\n\t\t\tproposal = ((event.calcPoint - data.start) * 100) / data.baseSize,\r\n\t\t\thandleNumber = handles[0] === scope_Handles[0] ? 0 : 1, i;\r\n\r\n\t\t// Calculate relative positions for the handles.\r\n\t\tpositions = getPositions( proposal, data.positions, handles.length > 1);\r\n\r\n\t\tstate = setHandle ( handles[0], positions[handleNumber], handles.length === 1 );\r\n\r\n\t\tif ( handles.length > 1 ) {\r\n\r\n\t\t\tstate = setHandle ( handles[1], positions[handleNumber?0:1], false ) || state;\r\n\r\n\t\t\tif ( state ) {\r\n\t\t\t\t// fire for both handles\r\n\t\t\t\tfor ( i = 0; i < data.handles.length; i++ ) {\r\n\t\t\t\t\tfireEvent('slide', i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if ( state ) {\r\n\t\t\t// Fire for a single handle\r\n\t\t\tfireEvent('slide', handleNumber);\r\n\t\t}\r\n\t}\r\n\r\n\t// Unbind move events on document, call callbacks.\r\n\tfunction end ( event, data ) {\r\n\r\n\t\t// The handle is no longer active, so remove the class.\r\n\t\tvar active = scope_Base.querySelector( '.' + cssClasses[15] ),\r\n\t\t\thandleNumber = data.handles[0] === scope_Handles[0] ? 0 : 1;\r\n\r\n\t\tif ( active !== null ) {\r\n\t\t\tremoveClass(active, cssClasses[15]);\r\n\t\t}\r\n\r\n\t\t// Remove cursor styles and text-selection events bound to the body.\r\n\t\tif ( event.cursor ) {\r\n\t\t\tdocument.body.style.cursor = '';\r\n\t\t\tdocument.body.removeEventListener('selectstart', document.body.noUiListener);\r\n\t\t}\r\n\r\n\t\tvar d = document.documentElement;\r\n\r\n\t\t// Unbind the move and end events, which are added on 'start'.\r\n\t\td.noUiListeners.forEach(function( c ) {\r\n\t\t\td.removeEventListener(c[0], c[1]);\r\n\t\t});\r\n\r\n\t\t// Remove dragging class.\r\n\t\tremoveClass(scope_Target, cssClasses[12]);\r\n\r\n\t\t// Fire the change and set events.\r\n\t\tfireEvent('set', handleNumber);\r\n\t\tfireEvent('change', handleNumber);\r\n\r\n\t\t// If this is a standard handle movement, fire the end event.\r\n\t\tif ( data.handleNumber !== undefined ) {\r\n\t\t\tfireEvent('end', data.handleNumber);\r\n\t\t}\r\n\t}\r\n\r\n\t// Fire 'end' when a mouse or pen leaves the document.\r\n\tfunction documentLeave ( event, data ) {\r\n\t\tif ( event.type === \"mouseout\" && event.target.nodeName === \"HTML\" && event.relatedTarget === null ){\r\n\t\t\tend ( event, data );\r\n\t\t}\r\n\t}\r\n\r\n\t// Bind move events on document.\r\n\tfunction start ( event, data ) {\r\n\r\n\t\tvar d = document.documentElement;\r\n\r\n\t\t// Mark the handle as 'active' so it can be styled.\r\n\t\tif ( data.handles.length === 1 ) {\r\n\t\t\taddClass(data.handles[0].children[0], cssClasses[15]);\r\n\r\n\t\t\t// Support 'disabled' handles\r\n\t\t\tif ( data.handles[0].hasAttribute('disabled') ) {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Fix #551, where a handle gets selected instead of dragged.\r\n\t\tevent.preventDefault();\r\n\r\n\t\t// A drag should never propagate up to the 'tap' event.\r\n\t\tevent.stopPropagation();\r\n\r\n\t\t// Attach the move and end events.\r\n\t\tvar moveEvent = attach(actions.move, d, move, {\r\n\t\t\tstart: event.calcPoint,\r\n\t\t\tbaseSize: baseSize(),\r\n\t\t\tpageOffset: event.pageOffset,\r\n\t\t\thandles: data.handles,\r\n\t\t\thandleNumber: data.handleNumber,\r\n\t\t\tbuttonsProperty: event.buttons,\r\n\t\t\tpositions: [\r\n\t\t\t\tscope_Locations[0],\r\n\t\t\t\tscope_Locations[scope_Handles.length - 1]\r\n\t\t\t]\r\n\t\t}), endEvent = attach(actions.end, d, end, {\r\n\t\t\thandles: data.handles,\r\n\t\t\thandleNumber: data.handleNumber\r\n\t\t});\r\n\r\n\t\tvar outEvent = attach(\"mouseout\", d, documentLeave, {\r\n\t\t\thandles: data.handles,\r\n\t\t\thandleNumber: data.handleNumber\r\n\t\t});\r\n\r\n\t\td.noUiListeners = moveEvent.concat(endEvent, outEvent);\r\n\r\n\t\t// Text selection isn't an issue on touch devices,\r\n\t\t// so adding cursor styles can be skipped.\r\n\t\tif ( event.cursor ) {\r\n\r\n\t\t\t// Prevent the 'I' cursor and extend the range-drag cursor.\r\n\t\t\tdocument.body.style.cursor = getComputedStyle(event.target).cursor;\r\n\r\n\t\t\t// Mark the target with a dragging state.\r\n\t\t\tif ( scope_Handles.length > 1 ) {\r\n\t\t\t\taddClass(scope_Target, cssClasses[12]);\r\n\t\t\t}\r\n\r\n\t\t\tvar f = function(){\r\n\t\t\t\treturn false;\r\n\t\t\t};\r\n\r\n\t\t\tdocument.body.noUiListener = f;\r\n\r\n\t\t\t// Prevent text selection when dragging the handles.\r\n\t\t\tdocument.body.addEventListener('selectstart', f, false);\r\n\t\t}\r\n\r\n\t\tif ( data.handleNumber !== undefined ) {\r\n\t\t\tfireEvent('start', data.handleNumber);\r\n\t\t}\r\n\t}\r\n\r\n\t// Move closest handle to tapped location.\r\n\tfunction tap ( event ) {\r\n\r\n\t\tvar location = event.calcPoint, total = 0, handleNumber, to;\r\n\r\n\t\t// The tap event shouldn't propagate up and cause 'edge' to run.\r\n\t\tevent.stopPropagation();\r\n\r\n\t\t// Add up the handle offsets.\r\n\t\tscope_Handles.forEach(function(a){\r\n\t\t\ttotal += offset(a)[ options.style ];\r\n\t\t});\r\n\r\n\t\t// Find the handle closest to the tapped position.\r\n\t\thandleNumber = ( location < total/2 || scope_Handles.length === 1 ) ? 0 : 1;\r\n\r\n\t\tlocation -= offset(scope_Base)[ options.style ];\r\n\r\n\t\t// Calculate the new position.\r\n\t\tto = ( location * 100 ) / baseSize();\r\n\r\n\t\tif ( !options.events.snap ) {\r\n\t\t\t// Flag the slider as it is now in a transitional state.\r\n\t\t\t// Transition takes 300 ms, so re-enable the slider afterwards.\r\n\t\t\taddClassFor( scope_Target, cssClasses[14], 300 );\r\n\t\t}\r\n\r\n\t\t// Support 'disabled' handles\r\n\t\tif ( scope_Handles[handleNumber].hasAttribute('disabled') ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Find the closest handle and calculate the tapped point.\r\n\t\t// The set handle to the new position.\r\n\t\tsetHandle( scope_Handles[handleNumber], to );\r\n\r\n\t\tfireEvent('slide', handleNumber, true);\r\n\t\tfireEvent('set', handleNumber, true);\r\n\t\tfireEvent('change', handleNumber, true);\r\n\r\n\t\tif ( options.events.snap ) {\r\n\t\t\tstart(event, { handles: [scope_Handles[handleNumber]] });\r\n\t\t}\r\n\t}\r\n\r\n\t// Fires a 'hover' event for a hovered mouse/pen position.\r\n\tfunction hover ( event ) {\r\n\r\n\t\tvar location = event.calcPoint - offset(scope_Base)[ options.style ],\r\n\t\t\tto = scope_Spectrum.getStep(( location * 100 ) / baseSize()),\r\n\t\t\tvalue = scope_Spectrum.fromStepping( to );\r\n\r\n\t\tObject.keys(scope_Events).forEach(function( targetEvent ) {\r\n\t\t\tif ( 'hover' === targetEvent.split('.')[0] ) {\r\n\t\t\t\tscope_Events[targetEvent].forEach(function( callback ) {\r\n\t\t\t\t\tcallback.call( scope_Self, value );\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Attach events to several slider parts.\r\n\tfunction events ( behaviour ) {\r\n\r\n\t\tvar i, drag;\r\n\r\n\t\t// Attach the standard drag event to the handles.\r\n\t\tif ( !behaviour.fixed ) {\r\n\r\n\t\t\tfor ( i = 0; i < scope_Handles.length; i += 1 ) {\r\n\r\n\t\t\t\t// These events are only bound to the visual handle\r\n\t\t\t\t// element, not the 'real' origin element.\r\n\t\t\t\tattach ( actions.start, scope_Handles[i].children[0], start, {\r\n\t\t\t\t\thandles: [ scope_Handles[i] ],\r\n\t\t\t\t\thandleNumber: i\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Attach the tap event to the slider base.\r\n\t\tif ( behaviour.tap ) {\r\n\r\n\t\t\tattach ( actions.start, scope_Base, tap, {\r\n\t\t\t\thandles: scope_Handles\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// Fire hover events\r\n\t\tif ( behaviour.hover ) {\r\n\t\t\tattach ( actions.move, scope_Base, hover, { hover: true } );\r\n\t\t\tfor ( i = 0; i < scope_Handles.length; i += 1 ) {\r\n\t\t\t\t['mousemove MSPointerMove pointermove'].forEach(function( eventName ){\r\n\t\t\t\t\tscope_Handles[i].children[0].addEventListener(eventName, stopPropagation, false);\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Make the range draggable.\r\n\t\tif ( behaviour.drag ){\r\n\r\n\t\t\tdrag = [scope_Base.querySelector( '.' + cssClasses[7] )];\r\n\t\t\taddClass(drag[0], cssClasses[10]);\r\n\r\n\t\t\t// When the range is fixed, the entire range can\r\n\t\t\t// be dragged by the handles. The handle in the first\r\n\t\t\t// origin will propagate the start event upward,\r\n\t\t\t// but it needs to be bound manually on the other.\r\n\t\t\tif ( behaviour.fixed ) {\r\n\t\t\t\tdrag.push(scope_Handles[(drag[0] === scope_Handles[0] ? 1 : 0)].children[0]);\r\n\t\t\t}\r\n\r\n\t\t\tdrag.forEach(function( element ) {\r\n\t\t\t\tattach ( actions.start, element, start, {\r\n\t\t\t\t\thandles: scope_Handles\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Test suggested values and apply margin, step.\r\n\tfunction setHandle ( handle, to, noLimitOption ) {\r\n\r\n\t\tvar trigger = handle !== scope_Handles[0] ? 1 : 0,\r\n\t\t\tlowerMargin = scope_Locations[0] + options.margin,\r\n\t\t\tupperMargin = scope_Locations[1] - options.margin,\r\n\t\t\tlowerLimit = scope_Locations[0] + options.limit,\r\n\t\t\tupperLimit = scope_Locations[1] - options.limit;\r\n\r\n\t\t// For sliders with multiple handles,\r\n\t\t// limit movement to the other handle.\r\n\t\t// Apply the margin option by adding it to the handle positions.\r\n\t\tif ( scope_Handles.length > 1 ) {\r\n\t\t\tto = trigger ? Math.max( to, lowerMargin ) : Math.min( to, upperMargin );\r\n\t\t}\r\n\r\n\t\t// The limit option has the opposite effect, limiting handles to a\r\n\t\t// maximum distance from another. Limit must be > 0, as otherwise\r\n\t\t// handles would be unmoveable. 'noLimitOption' is set to 'false'\r\n\t\t// for the .val() method, except for pass 4/4.\r\n\t\tif ( noLimitOption !== false && options.limit && scope_Handles.length > 1 ) {\r\n\t\t\tto = trigger ? Math.min ( to, lowerLimit ) : Math.max( to, upperLimit );\r\n\t\t}\r\n\r\n\t\t// Handle the step option.\r\n\t\tto = scope_Spectrum.getStep( to );\r\n\r\n\t\t// Limit to 0/100 for .val input, trim anything beyond 7 digits, as\r\n\t\t// JavaScript has some issues in its floating point implementation.\r\n\t\tto = limit(parseFloat(to.toFixed(7)));\r\n\r\n\t\t// Return false if handle can't move\r\n\t\tif ( to === scope_Locations[trigger] ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// Set the handle to the new position.\r\n\t\t// Use requestAnimationFrame for efficient painting.\r\n\t\t// No significant effect in Chrome, Edge sees dramatic\r\n\t\t// performace improvements.\r\n\t\tif ( window.requestAnimationFrame ) {\r\n\t\t\twindow.requestAnimationFrame(function(){\r\n\t\t\t\thandle.style[options.style] = to + '%';\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\thandle.style[options.style] = to + '%';\r\n\t\t}\r\n\r\n\t\t// Force proper handle stacking\r\n\t\tif ( !handle.previousSibling ) {\r\n\t\t\tremoveClass(handle, cssClasses[17]);\r\n\t\t\tif ( to > 50 ) {\r\n\t\t\t\taddClass(handle, cssClasses[17]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Update locations.\r\n\t\tscope_Locations[trigger] = to;\r\n\r\n\t\t// Convert the value to the slider stepping/range.\r\n\t\tscope_Values[trigger] = scope_Spectrum.fromStepping( to );\r\n\r\n\t\tfireEvent('update', trigger);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t// Loop values from value method and apply them.\r\n\tfunction setValues ( count, values ) {\r\n\r\n\t\tvar i, trigger, to;\r\n\r\n\t\t// With the limit option, we'll need another limiting pass.\r\n\t\tif ( options.limit ) {\r\n\t\t\tcount += 1;\r\n\t\t}\r\n\r\n\t\t// If there are multiple handles to be set run the setting\r\n\t\t// mechanism twice for the first handle, to make sure it\r\n\t\t// can be bounced of the second one properly.\r\n\t\tfor ( i = 0; i < count; i += 1 ) {\r\n\r\n\t\t\ttrigger = i%2;\r\n\r\n\t\t\t// Get the current argument from the array.\r\n\t\t\tto = values[trigger];\r\n\r\n\t\t\t// Setting with null indicates an 'ignore'.\r\n\t\t\t// Inputting 'false' is invalid.\r\n\t\t\tif ( to !== null && to !== false ) {\r\n\r\n\t\t\t\t// If a formatted number was passed, attemt to decode it.\r\n\t\t\t\tif ( typeof to === 'number' ) {\r\n\t\t\t\t\tto = String(to);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tto = options.format.from( to );\r\n\r\n\t\t\t\t// Request an update for all links if the value was invalid.\r\n\t\t\t\t// Do so too if setting the handle fails.\r\n\t\t\t\tif ( to === false || isNaN(to) || setHandle( scope_Handles[trigger], scope_Spectrum.toStepping( to ), i === (3 - options.dir) ) === false ) {\r\n\t\t\t\t\tfireEvent('update', trigger);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// Set the slider value.\r\n\tfunction valueSet ( input ) {\r\n\r\n\t\tvar count, values = asArray( input ), i;\r\n\r\n\t\t// The RTL settings is implemented by reversing the front-end,\r\n\t\t// internal mechanisms are the same.\r\n\t\tif ( options.dir && options.handles > 1 ) {\r\n\t\t\tvalues.reverse();\r\n\t\t}\r\n\r\n\t\t// Animation is optional.\r\n\t\t// Make sure the initial values where set before using animated placement.\r\n\t\tif ( options.animate && scope_Locations[0] !== -1 ) {\r\n\t\t\taddClassFor( scope_Target, cssClasses[14], 300 );\r\n\t\t}\r\n\r\n\t\t// Determine how often to set the handles.\r\n\t\tcount = scope_Handles.length > 1 ? 3 : 1;\r\n\r\n\t\tif ( values.length === 1 ) {\r\n\t\t\tcount = 1;\r\n\t\t}\r\n\r\n\t\tsetValues ( count, values );\r\n\r\n\t\t// Fire the 'set' event for both handles.\r\n\t\tfor ( i = 0; i < scope_Handles.length; i++ ) {\r\n\t\t\tfireEvent('set', i);\r\n\t\t}\r\n\t}\r\n\r\n\t// Get the slider value.\r\n\tfunction valueGet ( ) {\r\n\r\n\t\tvar i, retour = [];\r\n\r\n\t\t// Get the value from all handles.\r\n\t\tfor ( i = 0; i < options.handles; i += 1 ){\r\n\t\t\tretour[i] = options.format.to( scope_Values[i] );\r\n\t\t}\r\n\r\n\t\treturn inSliderOrder( retour );\r\n\t}\r\n\r\n\t// Removes classes from the root and empties it.\r\n\tfunction destroy ( ) {\r\n\t\tcssClasses.forEach(function(cls){\r\n\t\t\tif ( !cls ) { return; } // Ignore empty classes\r\n\t\t\tremoveClass(scope_Target, cls);\r\n\t\t});\r\n\t\tscope_Target.innerHTML = '';\r\n\t\tdelete scope_Target.noUiSlider;\r\n\t}\r\n\r\n\t// Get the current step size for the slider.\r\n\tfunction getCurrentStep ( ) {\r\n\r\n\t\t// Check all locations, map them to their stepping point.\r\n\t\t// Get the step point, then find it in the input list.\r\n\t\tvar retour = scope_Locations.map(function( location, index ){\r\n\r\n\t\t\tvar step = scope_Spectrum.getApplicableStep( location ),\r\n\r\n\t\t\t\t// As per #391, the comparison for the decrement step can have some rounding issues.\r\n\t\t\t\t// Round the value to the precision used in the step.\r\n\t\t\t\tstepDecimals = countDecimals(String(step[2])),\r\n\r\n\t\t\t\t// Get the current numeric value\r\n\t\t\t\tvalue = scope_Values[index],\r\n\r\n\t\t\t\t// To move the slider 'one step up', the current step value needs to be added.\r\n\t\t\t\t// Use null if we are at the maximum slider value.\r\n\t\t\t\tincrement = location === 100 ? null : step[2],\r\n\r\n\t\t\t\t// Going 'one step down' might put the slider in a different sub-range, so we\r\n\t\t\t\t// need to switch between the current or the previous step.\r\n\t\t\t\tprev = Number((value - step[2]).toFixed(stepDecimals)),\r\n\r\n\t\t\t\t// If the value fits the step, return the current step value. Otherwise, use the\r\n\t\t\t\t// previous step. Return null if the slider is at its minimum value.\r\n\t\t\t\tdecrement = location === 0 ? null : (prev >= step[1]) ? step[2] : (step[0] || false);\r\n\r\n\t\t\treturn [decrement, increment];\r\n\t\t});\r\n\r\n\t\t// Return values in the proper order.\r\n\t\treturn inSliderOrder( retour );\r\n\t}\r\n\r\n\t// Attach an event to this slider, possibly including a namespace\r\n\tfunction bindEvent ( namespacedEvent, callback ) {\r\n\t\tscope_Events[namespacedEvent] = scope_Events[namespacedEvent] || [];\r\n\t\tscope_Events[namespacedEvent].push(callback);\r\n\r\n\t\t// If the event bound is 'update,' fire it immediately for all handles.\r\n\t\tif ( namespacedEvent.split('.')[0] === 'update' ) {\r\n\t\t\tscope_Handles.forEach(function(a, index){\r\n\t\t\t\tfireEvent('update', index);\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n\r\n\t// Undo attachment of event\r\n\tfunction removeEvent ( namespacedEvent ) {\r\n\r\n\t\tvar event = namespacedEvent.split('.')[0],\r\n\t\t\tnamespace = namespacedEvent.substring(event.length);\r\n\r\n\t\tObject.keys(scope_Events).forEach(function( bind ){\r\n\r\n\t\t\tvar tEvent = bind.split('.')[0],\r\n\t\t\t\ttNamespace = bind.substring(tEvent.length);\r\n\r\n\t\t\tif ( (!event || event === tEvent) && (!namespace || namespace === tNamespace) ) {\r\n\t\t\t\tdelete scope_Events[bind];\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// Updateable: margin, limit, step, range, animate, snap\r\n\tfunction updateOptions ( optionsToUpdate ) {\r\n\r\n\t\tvar v = valueGet(), i, newOptions = testOptions({\r\n\t\t\tstart: [0, 0],\r\n\t\t\tmargin: optionsToUpdate.margin,\r\n\t\t\tlimit: optionsToUpdate.limit,\r\n\t\t\tstep: optionsToUpdate.step,\r\n\t\t\trange: optionsToUpdate.range,\r\n\t\t\tanimate: optionsToUpdate.animate,\r\n\t\t\tsnap: optionsToUpdate.snap === undefined ? options.snap : optionsToUpdate.snap\r\n\t\t});\r\n\r\n\t\t['margin', 'limit', 'step', 'range', 'animate'].forEach(function(name){\r\n\t\t\tif ( optionsToUpdate[name] !== undefined ) {\r\n\t\t\t\toptions[name] = optionsToUpdate[name];\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tscope_Spectrum = newOptions.spectrum;\r\n\r\n\t\t// Invalidate the current positioning so valueSet forces an update.\r\n\t\tscope_Locations = [-1, -1];\r\n\t\tvalueSet(v);\r\n\r\n\t\tfor ( i = 0; i < scope_Handles.length; i++ ) {\r\n\t\t\tfireEvent('update', i);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t// Throw an error if the slider was already initialized.\r\n\tif ( scope_Target.noUiSlider ) {\r\n\t\tthrow new Error('Slider was already initialized.');\r\n\t}\r\n\r\n\t// Create the base element, initialise HTML and set classes.\r\n\t// Add handles and links.\r\n\tscope_Base = addSlider( options.dir, options.ort, scope_Target );\r\n\tscope_Handles = addHandles( options.handles, options.dir, scope_Base );\r\n\r\n\t// Set the connect classes.\r\n\taddConnection ( options.connect, scope_Target, scope_Handles );\r\n\r\n\tif ( options.pips ) {\r\n\t\tpips(options.pips);\r\n\t}\r\n\r\n\tif ( options.tooltips ) {\r\n\t\ttooltips();\r\n\t}\r\n\r\n\tscope_Self = {\r\n\t\tdestroy: destroy,\r\n\t\tsteps: getCurrentStep,\r\n\t\ton: bindEvent,\r\n\t\toff: removeEvent,\r\n\t\tget: valueGet,\r\n\t\tset: valueSet,\r\n\t\tupdateOptions: updateOptions\r\n\t};\r\n\r\n\t// Attach user events.\r\n\tevents( options.events );\r\n\r\n\treturn scope_Self;\r\n\r\n}\r\n\r\n\r\n\t// Run the standard initializer\r\n\tfunction initialize ( target, originalOptions ) {\r\n\r\n\t\tif ( !target.nodeName ) {\r\n\t\t\tthrow new Error('noUiSlider.create requires a single element.');\r\n\t\t}\r\n\r\n\t\t// Test the options and create the slider environment;\r\n\t\tvar options = testOptions( originalOptions, target ),\r\n\t\t\tslider = closure( target, options );\r\n\r\n\t\t// Use the public value method to set the start values.\r\n\t\tslider.set(options.start);\r\n\r\n\t\ttarget.noUiSlider = slider;\r\n\t\treturn slider;\r\n\t}\r\n\r\n\t// Use an object instead of a function for future expansibility;\r\n\treturn {\r\n\t\tcreate: initialize\r\n\t};\r\n\r\n}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9ub3Vpc2xpZGVyL2Rpc3RyaWJ1dGUvbm91aXNsaWRlci5qcz85Y2ZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub3Vpc2xpZGVyIC0gOC4yLjEgLSAyMDE1LTEyLTAyIDIxOjQzOjE0ICovXHJcblxyXG4oZnVuY3Rpb24gKGZhY3RvcnkpIHtcclxuXHJcbiAgICBpZiAoIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuXHJcbiAgICAgICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxyXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XHJcblxyXG4gICAgfSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICkge1xyXG5cclxuICAgICAgICAvLyBOb2RlL0NvbW1vbkpTXHJcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzXHJcbiAgICAgICAgd2luZG93Lm5vVWlTbGlkZXIgPSBmYWN0b3J5KCk7XHJcbiAgICB9XHJcblxyXG59KGZ1bmN0aW9uKCApe1xyXG5cclxuXHQndXNlIHN0cmljdCc7XHJcblxyXG5cclxuXHQvLyBSZW1vdmVzIGR1cGxpY2F0ZXMgZnJvbSBhbiBhcnJheS5cclxuXHRmdW5jdGlvbiB1bmlxdWUoYXJyYXkpIHtcclxuXHRcdHJldHVybiBhcnJheS5maWx0ZXIoZnVuY3Rpb24oYSl7XHJcblx0XHRcdHJldHVybiAhdGhpc1thXSA/IHRoaXNbYV0gPSB0cnVlIDogZmFsc2U7XHJcblx0XHR9LCB7fSk7XHJcblx0fVxyXG5cclxuXHQvLyBSb3VuZCBhIHZhbHVlIHRvIHRoZSBjbG9zZXN0ICd0bycuXHJcblx0ZnVuY3Rpb24gY2xvc2VzdCAoIHZhbHVlLCB0byApIHtcclxuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbHVlIC8gdG8pICogdG87XHJcblx0fVxyXG5cclxuXHQvLyBDdXJyZW50IHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIGRvY3VtZW50LlxyXG5cdGZ1bmN0aW9uIG9mZnNldCAoIGVsZW0gKSB7XHJcblxyXG5cdHZhciByZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcclxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcclxuXHRcdGRvY0VsZW0gPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxyXG5cdFx0cGFnZU9mZnNldCA9IGdldFBhZ2VPZmZzZXQoKTtcclxuXHJcblx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QgY29udGFpbnMgbGVmdCBzY3JvbGwgaW4gQ2hyb21lIG9uIEFuZHJvaWQuXHJcblx0XHQvLyBJIGhhdmVuJ3QgZm91bmQgYSBmZWF0dXJlIGRldGVjdGlvbiB0aGF0IHByb3ZlcyB0aGlzLiBXb3JzdCBjYXNlXHJcblx0XHQvLyBzY2VuYXJpbyBvbiBtaXMtbWF0Y2g6IHRoZSAndGFwJyBmZWF0dXJlIG9uIGhvcml6b250YWwgc2xpZGVycyBicmVha3MuXHJcblx0XHRpZiAoIC93ZWJraXQuKkNocm9tZS4qTW9iaWxlL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSApIHtcclxuXHRcdFx0cGFnZU9mZnNldC54ID0gMDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHR0b3A6IHJlY3QudG9wICsgcGFnZU9mZnNldC55IC0gZG9jRWxlbS5jbGllbnRUb3AsXHJcblx0XHRcdGxlZnQ6IHJlY3QubGVmdCArIHBhZ2VPZmZzZXQueCAtIGRvY0VsZW0uY2xpZW50TGVmdFxyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8vIENoZWNrcyB3aGV0aGVyIGEgdmFsdWUgaXMgbnVtZXJpY2FsLlxyXG5cdGZ1bmN0aW9uIGlzTnVtZXJpYyAoIGEgKSB7XHJcblx0XHRyZXR1cm4gdHlwZW9mIGEgPT09ICdudW1iZXInICYmICFpc05hTiggYSApICYmIGlzRmluaXRlKCBhICk7XHJcblx0fVxyXG5cclxuXHQvLyBSb3VuZHMgYSBudW1iZXIgdG8gNyBzdXBwb3J0ZWQgZGVjaW1hbHMuXHJcblx0ZnVuY3Rpb24gYWNjdXJhdGVOdW1iZXIoIG51bWJlciApIHtcclxuXHRcdHZhciBwID0gTWF0aC5wb3coMTAsIDcpO1xyXG5cdFx0cmV0dXJuIE51bWJlcigoTWF0aC5yb3VuZChudW1iZXIqcCkvcCkudG9GaXhlZCg3KSk7XHJcblx0fVxyXG5cclxuXHQvLyBTZXRzIGEgY2xhc3MgYW5kIHJlbW92ZXMgaXQgYWZ0ZXIgW2R1cmF0aW9uXSBtcy5cclxuXHRmdW5jdGlvbiBhZGRDbGFzc0ZvciAoIGVsZW1lbnQsIGNsYXNzTmFtZSwgZHVyYXRpb24gKSB7XHJcblx0XHRhZGRDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbigpe1xyXG5cdFx0XHRyZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpO1xyXG5cdFx0fSwgZHVyYXRpb24pO1xyXG5cdH1cclxuXHJcblx0Ly8gTGltaXRzIGEgdmFsdWUgdG8gMCAtIDEwMFxyXG5cdGZ1bmN0aW9uIGxpbWl0ICggYSApIHtcclxuXHRcdHJldHVybiBNYXRoLm1heChNYXRoLm1pbihhLCAxMDApLCAwKTtcclxuXHR9XHJcblxyXG5cdC8vIFdyYXBzIGEgdmFyaWFibGUgYXMgYW4gYXJyYXksIGlmIGl0IGlzbid0IG9uZSB5ZXQuXHJcblx0ZnVuY3Rpb24gYXNBcnJheSAoIGEgKSB7XHJcblx0XHRyZXR1cm4gQXJyYXkuaXNBcnJheShhKSA/IGEgOiBbYV07XHJcblx0fVxyXG5cclxuXHQvLyBDb3VudHMgZGVjaW1hbHNcclxuXHRmdW5jdGlvbiBjb3VudERlY2ltYWxzICggbnVtU3RyICkge1xyXG5cdFx0dmFyIHBpZWNlcyA9IG51bVN0ci5zcGxpdChcIi5cIik7XHJcblx0XHRyZXR1cm4gcGllY2VzLmxlbmd0aCA+IDEgPyBwaWVjZXNbMV0ubGVuZ3RoIDogMDtcclxuXHR9XHJcblxyXG5cdC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNhZGRfY2xhc3NcclxuXHRmdW5jdGlvbiBhZGRDbGFzcyAoIGVsLCBjbGFzc05hbWUgKSB7XHJcblx0XHRpZiAoIGVsLmNsYXNzTGlzdCApIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZWwuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNyZW1vdmVfY2xhc3NcclxuXHRmdW5jdGlvbiByZW1vdmVDbGFzcyAoIGVsLCBjbGFzc05hbWUgKSB7XHJcblx0XHRpZiAoIGVsLmNsYXNzTGlzdCApIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXGIpJyArIGNsYXNzTmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoXFxcXGJ8JCknLCAnZ2knKSwgJyAnKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIGh0dHA6Ly95b3VtaWdodG5vdG5lZWRqcXVlcnkuY29tLyNoYXNfY2xhc3NcclxuXHRmdW5jdGlvbiBoYXNDbGFzcyAoIGVsLCBjbGFzc05hbWUgKSB7XHJcblx0XHRpZiAoIGVsLmNsYXNzTGlzdCApIHtcclxuXHRcdFx0ZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuZXcgUmVnRXhwKCcoXnwgKScgKyBjbGFzc05hbWUgKyAnKCB8JCknLCAnZ2knKS50ZXN0KGVsLmNsYXNzTmFtZSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3Njcm9sbFkjTm90ZXNcclxuXHRmdW5jdGlvbiBnZXRQYWdlT2Zmc2V0ICggKSB7XHJcblxyXG5cdFx0dmFyIHN1cHBvcnRQYWdlT2Zmc2V0ID0gd2luZG93LnBhZ2VYT2Zmc2V0ICE9PSB1bmRlZmluZWQsXHJcblx0XHRcdGlzQ1NTMUNvbXBhdCA9ICgoZG9jdW1lbnQuY29tcGF0TW9kZSB8fCBcIlwiKSA9PT0gXCJDU1MxQ29tcGF0XCIpLFxyXG5cdFx0XHR4ID0gc3VwcG9ydFBhZ2VPZmZzZXQgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiBpc0NTUzFDb21wYXQgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCA6IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcclxuXHRcdFx0eSA9IHN1cHBvcnRQYWdlT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogaXNDU1MxQ29tcGF0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCA6IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHg6IHgsXHJcblx0XHRcdHk6IHlcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvLyBTaG9ydGhhbmQgZm9yIHN0b3BQcm9wYWdhdGlvbiBzbyB3ZSBkb24ndCBoYXZlIHRvIGNyZWF0ZSBhIGR5bmFtaWMgbWV0aG9kXHJcblx0ZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICggZSApIHtcclxuXHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0fVxyXG5cclxuXHQvLyB0b2RvXHJcblx0ZnVuY3Rpb24gYWRkQ3NzUHJlZml4KGNzc1ByZWZpeCkge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xyXG5cdFx0XHRyZXR1cm4gY3NzUHJlZml4ICsgY2xhc3NOYW1lO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cclxuXHR2YXJcclxuXHQvLyBEZXRlcm1pbmUgdGhlIGV2ZW50cyB0byBiaW5kLiBJRTExIGltcGxlbWVudHMgcG9pbnRlckV2ZW50cyB3aXRob3V0XHJcblx0Ly8gYSBwcmVmaXgsIHdoaWNoIGJyZWFrcyBjb21wYXRpYmlsaXR5IHdpdGggdGhlIElFMTAgaW1wbGVtZW50YXRpb24uXHJcblx0LyoqIEBjb25zdCAqL1xyXG5cdGFjdGlvbnMgPSB3aW5kb3cubmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkID8ge1xyXG5cdFx0c3RhcnQ6ICdwb2ludGVyZG93bicsXHJcblx0XHRtb3ZlOiAncG9pbnRlcm1vdmUnLFxyXG5cdFx0ZW5kOiAncG9pbnRlcnVwJ1xyXG5cdH0gOiB3aW5kb3cubmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQgPyB7XHJcblx0XHRzdGFydDogJ01TUG9pbnRlckRvd24nLFxyXG5cdFx0bW92ZTogJ01TUG9pbnRlck1vdmUnLFxyXG5cdFx0ZW5kOiAnTVNQb2ludGVyVXAnXHJcblx0fSA6IHtcclxuXHRcdHN0YXJ0OiAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLFxyXG5cdFx0bW92ZTogJ21vdXNlbW92ZSB0b3VjaG1vdmUnLFxyXG5cdFx0ZW5kOiAnbW91c2V1cCB0b3VjaGVuZCdcclxuXHR9LFxyXG5cdGRlZmF1bHRDc3NQcmVmaXggPSAnbm9VaS0nO1xyXG5cclxuXHJcbi8vIFZhbHVlIGNhbGN1bGF0aW9uXHJcblxyXG5cdC8vIERldGVybWluZSB0aGUgc2l6ZSBvZiBhIHN1Yi1yYW5nZSBpbiByZWxhdGlvbiB0byBhIGZ1bGwgcmFuZ2UuXHJcblx0ZnVuY3Rpb24gc3ViUmFuZ2VSYXRpbyAoIHBhLCBwYiApIHtcclxuXHRcdHJldHVybiAoMTAwIC8gKHBiIC0gcGEpKTtcclxuXHR9XHJcblxyXG5cdC8vIChwZXJjZW50YWdlKSBIb3cgbWFueSBwZXJjZW50IGlzIHRoaXMgdmFsdWUgb2YgdGhpcyByYW5nZT9cclxuXHRmdW5jdGlvbiBmcm9tUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiAodmFsdWUgKiAxMDApIC8gKCByYW5nZVsxXSAtIHJhbmdlWzBdICk7XHJcblx0fVxyXG5cclxuXHQvLyAocGVyY2VudGFnZSkgV2hlcmUgaXMgdGhpcyB2YWx1ZSBvbiB0aGlzIHJhbmdlP1xyXG5cdGZ1bmN0aW9uIHRvUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiBmcm9tUGVyY2VudGFnZSggcmFuZ2UsIHJhbmdlWzBdIDwgMCA/XHJcblx0XHRcdHZhbHVlICsgTWF0aC5hYnMocmFuZ2VbMF0pIDpcclxuXHRcdFx0XHR2YWx1ZSAtIHJhbmdlWzBdICk7XHJcblx0fVxyXG5cclxuXHQvLyAodmFsdWUpIEhvdyBtdWNoIGlzIHRoaXMgcGVyY2VudGFnZSBvbiB0aGlzIHJhbmdlP1xyXG5cdGZ1bmN0aW9uIGlzUGVyY2VudGFnZSAoIHJhbmdlLCB2YWx1ZSApIHtcclxuXHRcdHJldHVybiAoKHZhbHVlICogKCByYW5nZVsxXSAtIHJhbmdlWzBdICkpIC8gMTAwKSArIHJhbmdlWzBdO1xyXG5cdH1cclxuXHJcblxyXG4vLyBSYW5nZSBjb252ZXJzaW9uXHJcblxyXG5cdGZ1bmN0aW9uIGdldEogKCB2YWx1ZSwgYXJyICkge1xyXG5cclxuXHRcdHZhciBqID0gMTtcclxuXHJcblx0XHR3aGlsZSAoIHZhbHVlID49IGFycltqXSApe1xyXG5cdFx0XHRqICs9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGo7XHJcblx0fVxyXG5cclxuXHQvLyAocGVyY2VudGFnZSkgSW5wdXQgYSB2YWx1ZSwgZmluZCB3aGVyZSwgb24gYSBzY2FsZSBvZiAwLTEwMCwgaXQgYXBwbGllcy5cclxuXHRmdW5jdGlvbiB0b1N0ZXBwaW5nICggeFZhbCwgeFBjdCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCB2YWx1ZSA+PSB4VmFsLnNsaWNlKC0xKVswXSApe1xyXG5cdFx0XHRyZXR1cm4gMTAwO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBqID0gZ2V0SiggdmFsdWUsIHhWYWwgKSwgdmEsIHZiLCBwYSwgcGI7XHJcblxyXG5cdFx0dmEgPSB4VmFsW2otMV07XHJcblx0XHR2YiA9IHhWYWxbal07XHJcblx0XHRwYSA9IHhQY3Rbai0xXTtcclxuXHRcdHBiID0geFBjdFtqXTtcclxuXHJcblx0XHRyZXR1cm4gcGEgKyAodG9QZXJjZW50YWdlKFt2YSwgdmJdLCB2YWx1ZSkgLyBzdWJSYW5nZVJhdGlvIChwYSwgcGIpKTtcclxuXHR9XHJcblxyXG5cdC8vICh2YWx1ZSkgSW5wdXQgYSBwZXJjZW50YWdlLCBmaW5kIHdoZXJlIGl0IGlzIG9uIHRoZSBzcGVjaWZpZWQgcmFuZ2UuXHJcblx0ZnVuY3Rpb24gZnJvbVN0ZXBwaW5nICggeFZhbCwgeFBjdCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gVGhlcmUgaXMgbm8gcmFuZ2UgZ3JvdXAgdGhhdCBmaXRzIDEwMFxyXG5cdFx0aWYgKCB2YWx1ZSA+PSAxMDAgKXtcclxuXHRcdFx0cmV0dXJuIHhWYWwuc2xpY2UoLTEpWzBdO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBqID0gZ2V0SiggdmFsdWUsIHhQY3QgKSwgdmEsIHZiLCBwYSwgcGI7XHJcblxyXG5cdFx0dmEgPSB4VmFsW2otMV07XHJcblx0XHR2YiA9IHhWYWxbal07XHJcblx0XHRwYSA9IHhQY3Rbai0xXTtcclxuXHRcdHBiID0geFBjdFtqXTtcclxuXHJcblx0XHRyZXR1cm4gaXNQZXJjZW50YWdlKFt2YSwgdmJdLCAodmFsdWUgLSBwYSkgKiBzdWJSYW5nZVJhdGlvIChwYSwgcGIpKTtcclxuXHR9XHJcblxyXG5cdC8vIChwZXJjZW50YWdlKSBHZXQgdGhlIHN0ZXAgdGhhdCBhcHBsaWVzIGF0IGEgY2VydGFpbiB2YWx1ZS5cclxuXHRmdW5jdGlvbiBnZXRTdGVwICggeFBjdCwgeFN0ZXBzLCBzbmFwLCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIHZhbHVlID09PSAxMDAgKSB7XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaiA9IGdldEooIHZhbHVlLCB4UGN0ICksIGEsIGI7XHJcblxyXG5cdFx0Ly8gSWYgJ3NuYXAnIGlzIHNldCwgc3RlcHMgYXJlIHVzZWQgYXMgZml4ZWQgcG9pbnRzIG9uIHRoZSBzbGlkZXIuXHJcblx0XHRpZiAoIHNuYXAgKSB7XHJcblxyXG5cdFx0XHRhID0geFBjdFtqLTFdO1xyXG5cdFx0XHRiID0geFBjdFtqXTtcclxuXHJcblx0XHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgcG9zaXRpb24sIGEgb3IgYi5cclxuXHRcdFx0aWYgKCh2YWx1ZSAtIGEpID4gKChiLWEpLzIpKXtcclxuXHRcdFx0XHRyZXR1cm4gYjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAheFN0ZXBzW2otMV0gKXtcclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB4UGN0W2otMV0gKyBjbG9zZXN0KFxyXG5cdFx0XHR2YWx1ZSAtIHhQY3Rbai0xXSxcclxuXHRcdFx0eFN0ZXBzW2otMV1cclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHJcbi8vIEVudHJ5IHBhcnNpbmdcclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlRW50cnlQb2ludCAoIGluZGV4LCB2YWx1ZSwgdGhhdCApIHtcclxuXHJcblx0XHR2YXIgcGVyY2VudGFnZTtcclxuXHJcblx0XHQvLyBXcmFwIG51bWVyaWNhbCBpbnB1dCBpbiBhbiBhcnJheS5cclxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICkge1xyXG5cdFx0XHR2YWx1ZSA9IFt2YWx1ZV07XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gUmVqZWN0IGFueSBpbnZhbGlkIGlucHV0LCBieSB0ZXN0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYW4gYXJyYXkuXHJcblx0XHRpZiAoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggdmFsdWUgKSAhPT0gJ1tvYmplY3QgQXJyYXldJyApe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnIGNvbnRhaW5zIGludmFsaWQgdmFsdWUuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENvdmVydCBtaW4vbWF4IHN5bnRheCB0byAwIGFuZCAxMDAuXHJcblx0XHRpZiAoIGluZGV4ID09PSAnbWluJyApIHtcclxuXHRcdFx0cGVyY2VudGFnZSA9IDA7XHJcblx0XHR9IGVsc2UgaWYgKCBpbmRleCA9PT0gJ21heCcgKSB7XHJcblx0XHRcdHBlcmNlbnRhZ2UgPSAxMDA7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwZXJjZW50YWdlID0gcGFyc2VGbG9hdCggaW5kZXggKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDaGVjayBmb3IgY29ycmVjdCBpbnB1dC5cclxuXHRcdGlmICggIWlzTnVtZXJpYyggcGVyY2VudGFnZSApIHx8ICFpc051bWVyaWMoIHZhbHVlWzBdICkgKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdyYW5nZScgdmFsdWUgaXNuJ3QgbnVtZXJpYy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU3RvcmUgdmFsdWVzLlxyXG5cdFx0dGhhdC54UGN0LnB1c2goIHBlcmNlbnRhZ2UgKTtcclxuXHRcdHRoYXQueFZhbC5wdXNoKCB2YWx1ZVswXSApO1xyXG5cclxuXHRcdC8vIE5hTiB3aWxsIGV2YWx1YXRlIHRvIGZhbHNlIHRvbywgYnV0IHRvIGtlZXBcclxuXHRcdC8vIGxvZ2dpbmcgY2xlYXIsIHNldCBzdGVwIGV4cGxpY2l0bHkuIE1ha2Ugc3VyZVxyXG5cdFx0Ly8gbm90IHRvIG92ZXJyaWRlIHRoZSAnc3RlcCcgc2V0dGluZyB3aXRoIGZhbHNlLlxyXG5cdFx0aWYgKCAhcGVyY2VudGFnZSApIHtcclxuXHRcdFx0aWYgKCAhaXNOYU4oIHZhbHVlWzFdICkgKSB7XHJcblx0XHRcdFx0dGhhdC54U3RlcHNbMF0gPSB2YWx1ZVsxXTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhhdC54U3RlcHMucHVzaCggaXNOYU4odmFsdWVbMV0pID8gZmFsc2UgOiB2YWx1ZVsxXSApO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlU3RlcFBvaW50ICggaSwgbiwgdGhhdCApIHtcclxuXHJcblx0XHQvLyBJZ25vcmUgJ2ZhbHNlJyBzdGVwcGluZy5cclxuXHRcdGlmICggIW4gKSB7XHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZhY3RvciB0byByYW5nZSByYXRpb1xyXG5cdFx0dGhhdC54U3RlcHNbaV0gPSBmcm9tUGVyY2VudGFnZShbXHJcblx0XHRcdCB0aGF0LnhWYWxbaV1cclxuXHRcdFx0LHRoYXQueFZhbFtpKzFdXHJcblx0XHRdLCBuKSAvIHN1YlJhbmdlUmF0aW8gKFxyXG5cdFx0XHR0aGF0LnhQY3RbaV0sXHJcblx0XHRcdHRoYXQueFBjdFtpKzFdICk7XHJcblx0fVxyXG5cclxuXHJcbi8vIEludGVyZmFjZVxyXG5cclxuXHQvLyBUaGUgaW50ZXJmYWNlIHRvIFNwZWN0cnVtIGhhbmRsZXMgYWxsIGRpcmVjdGlvbi1iYXNlZFxyXG5cdC8vIGNvbnZlcnNpb25zLCBzbyB0aGUgYWJvdmUgdmFsdWVzIGFyZSB1bmF3YXJlLlxyXG5cclxuXHRmdW5jdGlvbiBTcGVjdHJ1bSAoIGVudHJ5LCBzbmFwLCBkaXJlY3Rpb24sIHNpbmdsZVN0ZXAgKSB7XHJcblxyXG5cdFx0dGhpcy54UGN0ID0gW107XHJcblx0XHR0aGlzLnhWYWwgPSBbXTtcclxuXHRcdHRoaXMueFN0ZXBzID0gWyBzaW5nbGVTdGVwIHx8IGZhbHNlIF07XHJcblx0XHR0aGlzLnhOdW1TdGVwcyA9IFsgZmFsc2UgXTtcclxuXHJcblx0XHR0aGlzLnNuYXAgPSBzbmFwO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24gPSBkaXJlY3Rpb247XHJcblxyXG5cdFx0dmFyIGluZGV4LCBvcmRlcmVkID0gWyAvKiBbMCwgJ21pbiddLCBbMSwgJzUwJSddLCBbMiwgJ21heCddICovIF07XHJcblxyXG5cdFx0Ly8gTWFwIHRoZSBvYmplY3Qga2V5cyB0byBhbiBhcnJheS5cclxuXHRcdGZvciAoIGluZGV4IGluIGVudHJ5ICkge1xyXG5cdFx0XHRpZiAoIGVudHJ5Lmhhc093blByb3BlcnR5KGluZGV4KSApIHtcclxuXHRcdFx0XHRvcmRlcmVkLnB1c2goW2VudHJ5W2luZGV4XSwgaW5kZXhdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFNvcnQgYWxsIGVudHJpZXMgYnkgdmFsdWUgKG51bWVyaWMgc29ydCkuXHJcblx0XHRpZiAoIG9yZGVyZWQubGVuZ3RoICYmIHR5cGVvZiBvcmRlcmVkWzBdWzBdID09PSBcIm9iamVjdFwiICkge1xyXG5cdFx0XHRvcmRlcmVkLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVswXVswXSAtIGJbMF1bMF07IH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b3JkZXJlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9KTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0Ly8gQ29udmVydCBhbGwgZW50cmllcyB0byBzdWJyYW5nZXMuXHJcblx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgb3JkZXJlZC5sZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRcdGhhbmRsZUVudHJ5UG9pbnQob3JkZXJlZFtpbmRleF1bMV0sIG9yZGVyZWRbaW5kZXhdWzBdLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBTdG9yZSB0aGUgYWN0dWFsIHN0ZXAgdmFsdWVzLlxyXG5cdFx0Ly8geFN0ZXBzIGlzIHNvcnRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB4UGN0IGFuZCB4VmFsLlxyXG5cdFx0dGhpcy54TnVtU3RlcHMgPSB0aGlzLnhTdGVwcy5zbGljZSgwKTtcclxuXHJcblx0XHQvLyBDb252ZXJ0IGFsbCBudW1lcmljIHN0ZXBzIHRvIHRoZSBwZXJjZW50YWdlIG9mIHRoZSBzdWJyYW5nZSB0aGV5IHJlcHJlc2VudC5cclxuXHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnhOdW1TdGVwcy5sZW5ndGg7IGluZGV4KysgKSB7XHJcblx0XHRcdGhhbmRsZVN0ZXBQb2ludChpbmRleCwgdGhpcy54TnVtU3RlcHNbaW5kZXhdLCB0aGlzKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS5nZXRNYXJnaW4gPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0cmV0dXJuIHRoaXMueFBjdC5sZW5ndGggPT09IDIgPyBmcm9tUGVyY2VudGFnZSh0aGlzLnhWYWwsIHZhbHVlKSA6IGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdFNwZWN0cnVtLnByb3RvdHlwZS50b1N0ZXBwaW5nID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHR2YWx1ZSA9IHRvU3RlcHBpbmcoIHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSApO1xyXG5cclxuXHRcdC8vIEludmVydCB0aGUgdmFsdWUgaWYgdGhpcyBpcyBhIHJpZ2h0LXRvLWxlZnQgc2xpZGVyLlxyXG5cdFx0aWYgKCB0aGlzLmRpcmVjdGlvbiApIHtcclxuXHRcdFx0dmFsdWUgPSAxMDAgLSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fTtcclxuXHJcblx0U3BlY3RydW0ucHJvdG90eXBlLmZyb21TdGVwcGluZyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gSW52ZXJ0IHRoZSB2YWx1ZSBpZiB0aGlzIGlzIGEgcmlnaHQtdG8tbGVmdCBzbGlkZXIuXHJcblx0XHRpZiAoIHRoaXMuZGlyZWN0aW9uICkge1xyXG5cdFx0XHR2YWx1ZSA9IDEwMCAtIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhY2N1cmF0ZU51bWJlcihmcm9tU3RlcHBpbmcoIHRoaXMueFZhbCwgdGhpcy54UGN0LCB2YWx1ZSApKTtcclxuXHR9O1xyXG5cclxuXHRTcGVjdHJ1bS5wcm90b3R5cGUuZ2V0U3RlcCA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gRmluZCB0aGUgcHJvcGVyIHN0ZXAgZm9yIHJ0bCBzbGlkZXJzIGJ5IHNlYXJjaCBpbiBpbnZlcnNlIGRpcmVjdGlvbi5cclxuXHRcdC8vIEZpeGVzIGlzc3VlICMyNjIuXHJcblx0XHRpZiAoIHRoaXMuZGlyZWN0aW9uICkge1xyXG5cdFx0XHR2YWx1ZSA9IDEwMCAtIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhbHVlID0gZ2V0U3RlcCh0aGlzLnhQY3QsIHRoaXMueFN0ZXBzLCB0aGlzLnNuYXAsIHZhbHVlICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmRpcmVjdGlvbiApIHtcclxuXHRcdFx0dmFsdWUgPSAxMDAgLSB2YWx1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fTtcclxuXHJcblx0U3BlY3RydW0ucHJvdG90eXBlLmdldEFwcGxpY2FibGVTdGVwID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHQvLyBJZiB0aGUgdmFsdWUgaXMgMTAwJSwgcmV0dXJuIHRoZSBuZWdhdGl2ZSBzdGVwIHR3aWNlLlxyXG5cdFx0dmFyIGogPSBnZXRKKHZhbHVlLCB0aGlzLnhQY3QpLCBvZmZzZXQgPSB2YWx1ZSA9PT0gMTAwID8gMiA6IDE7XHJcblx0XHRyZXR1cm4gW3RoaXMueE51bVN0ZXBzW2otMl0sIHRoaXMueFZhbFtqLW9mZnNldF0sIHRoaXMueE51bVN0ZXBzW2otb2Zmc2V0XV07XHJcblx0fTtcclxuXHJcblx0Ly8gT3V0c2lkZSB0ZXN0aW5nXHJcblx0U3BlY3RydW0ucHJvdG90eXBlLmNvbnZlcnQgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3RlcCh0aGlzLnRvU3RlcHBpbmcodmFsdWUpKTtcclxuXHR9O1xyXG5cclxuLypcdEV2ZXJ5IGlucHV0IG9wdGlvbiBpcyB0ZXN0ZWQgYW5kIHBhcnNlZC4gVGhpcydsbCBwcmV2ZW50XHJcblx0ZW5kbGVzcyB2YWxpZGF0aW9uIGluIGludGVybmFsIG1ldGhvZHMuIFRoZXNlIHRlc3RzIGFyZVxyXG5cdHN0cnVjdHVyZWQgd2l0aCBhbiBpdGVtIGZvciBldmVyeSBvcHRpb24gYXZhaWxhYmxlLiBBblxyXG5cdG9wdGlvbiBjYW4gYmUgbWFya2VkIGFzIHJlcXVpcmVkIGJ5IHNldHRpbmcgdGhlICdyJyBmbGFnLlxyXG5cdFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxyXG5cdFx0LSBUaGUgcHJvdmlkZWQgdmFsdWUgZm9yIHRoZSBvcHRpb247XHJcblx0XHQtIEEgcmVmZXJlbmNlIHRvIHRoZSBvcHRpb25zIG9iamVjdDtcclxuXHRcdC0gVGhlIG5hbWUgZm9yIHRoZSBvcHRpb247XHJcblxyXG5cdFRoZSB0ZXN0aW5nIGZ1bmN0aW9uIHJldHVybnMgZmFsc2Ugd2hlbiBhbiBlcnJvciBpcyBkZXRlY3RlZCxcclxuXHRvciB0cnVlIHdoZW4gZXZlcnl0aGluZyBpcyBPSy4gSXQgY2FuIGFsc28gbW9kaWZ5IHRoZSBvcHRpb25cclxuXHRvYmplY3QsIHRvIG1ha2Ugc3VyZSBhbGwgdmFsdWVzIGNhbiBiZSBjb3JyZWN0bHkgbG9vcGVkIGVsc2V3aGVyZS4gKi9cclxuXHJcblx0dmFyIGRlZmF1bHRGb3JtYXR0ZXIgPSB7ICd0byc6IGZ1bmN0aW9uKCB2YWx1ZSApe1xyXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUudG9GaXhlZCgyKTtcclxuXHR9LCAnZnJvbSc6IE51bWJlciB9O1xyXG5cclxuXHRmdW5jdGlvbiB0ZXN0U3RlcCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0aWYgKCAhaXNOdW1lcmljKCBlbnRyeSApICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnc3RlcCcgaXMgbm90IG51bWVyaWMuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZSBzdGVwIG9wdGlvbiBjYW4gc3RpbGwgYmUgdXNlZCB0byBzZXQgc3RlcHBpbmdcclxuXHRcdC8vIGZvciBsaW5lYXIgc2xpZGVycy4gT3ZlcndyaXR0ZW4gaWYgc2V0IGluICdyYW5nZScuXHJcblx0XHRwYXJzZWQuc2luZ2xlU3RlcCA9IGVudHJ5O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdFJhbmdlICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBGaWx0ZXIgaW5jb3JyZWN0IGlucHV0LlxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkoZW50cnkpICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnIGlzIG5vdCBhbiBvYmplY3QuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIENhdGNoIG1pc3Npbmcgc3RhcnQgb3IgZW5kLlxyXG5cdFx0aWYgKCBlbnRyeS5taW4gPT09IHVuZGVmaW5lZCB8fCBlbnRyeS5tYXggPT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogTWlzc2luZyAnbWluJyBvciAnbWF4JyBpbiAncmFuZ2UnLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBDYXRjaCBlcXVhbCBzdGFydCBvciBlbmQuXHJcblx0XHRpZiAoIGVudHJ5Lm1pbiA9PT0gZW50cnkubWF4ICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAncmFuZ2UnICdtaW4nIGFuZCAnbWF4JyBjYW5ub3QgYmUgZXF1YWwuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHBhcnNlZC5zcGVjdHJ1bSA9IG5ldyBTcGVjdHJ1bShlbnRyeSwgcGFyc2VkLnNuYXAsIHBhcnNlZC5kaXIsIHBhcnNlZC5zaW5nbGVTdGVwKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RTdGFydCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0ZW50cnkgPSBhc0FycmF5KGVudHJ5KTtcclxuXHJcblx0XHQvLyBWYWxpZGF0ZSBpbnB1dC4gVmFsdWVzIGFyZW4ndCB0ZXN0ZWQsIGFzIHRoZSBwdWJsaWMgLnZhbCBtZXRob2RcclxuXHRcdC8vIHdpbGwgYWx3YXlzIHByb3ZpZGUgYSB2YWxpZCBsb2NhdGlvbi5cclxuXHRcdGlmICggIUFycmF5LmlzQXJyYXkoIGVudHJ5ICkgfHwgIWVudHJ5Lmxlbmd0aCB8fCBlbnRyeS5sZW5ndGggPiAyICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnc3RhcnQnIG9wdGlvbiBpcyBpbmNvcnJlY3QuXCIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFN0b3JlIHRoZSBudW1iZXIgb2YgaGFuZGxlcy5cclxuXHRcdHBhcnNlZC5oYW5kbGVzID0gZW50cnkubGVuZ3RoO1xyXG5cclxuXHRcdC8vIFdoZW4gdGhlIHNsaWRlciBpcyBpbml0aWFsaXplZCwgdGhlIC52YWwgbWV0aG9kIHdpbGxcclxuXHRcdC8vIGJlIGNhbGxlZCB3aXRoIHRoZSBzdGFydCBvcHRpb25zLlxyXG5cdFx0cGFyc2VkLnN0YXJ0ID0gZW50cnk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0U25hcCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0Ly8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXHJcblx0XHRwYXJzZWQuc25hcCA9IGVudHJ5O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIGVudHJ5ICE9PSAnYm9vbGVhbicgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ3NuYXAnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0QW5pbWF0ZSAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0Ly8gRW5mb3JjZSAxMDAlIHN0ZXBwaW5nIHdpdGhpbiBzdWJyYW5nZXMuXHJcblx0XHRwYXJzZWQuYW5pbWF0ZSA9IGVudHJ5O1xyXG5cclxuXHRcdGlmICggdHlwZW9mIGVudHJ5ICE9PSAnYm9vbGVhbicgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2FuaW1hdGUnIG9wdGlvbiBtdXN0IGJlIGEgYm9vbGVhbi5cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0Q29ubmVjdCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0aWYgKCBlbnRyeSA9PT0gJ2xvd2VyJyAmJiBwYXJzZWQuaGFuZGxlcyA9PT0gMSApIHtcclxuXHRcdFx0cGFyc2VkLmNvbm5lY3QgPSAxO1xyXG5cdFx0fSBlbHNlIGlmICggZW50cnkgPT09ICd1cHBlcicgJiYgcGFyc2VkLmhhbmRsZXMgPT09IDEgKSB7XHJcblx0XHRcdHBhcnNlZC5jb25uZWN0ID0gMjtcclxuXHRcdH0gZWxzZSBpZiAoIGVudHJ5ID09PSB0cnVlICYmIHBhcnNlZC5oYW5kbGVzID09PSAyICkge1xyXG5cdFx0XHRwYXJzZWQuY29ubmVjdCA9IDM7XHJcblx0XHR9IGVsc2UgaWYgKCBlbnRyeSA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdHBhcnNlZC5jb25uZWN0ID0gMDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdjb25uZWN0JyBvcHRpb24gZG9lc24ndCBtYXRjaCBoYW5kbGUgY291bnQuXCIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdE9yaWVudGF0aW9uICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBTZXQgb3JpZW50YXRpb24gdG8gYW4gYSBudW1lcmljYWwgdmFsdWUgZm9yIGVhc3lcclxuXHRcdC8vIGFycmF5IHNlbGVjdGlvbi5cclxuXHRcdHN3aXRjaCAoIGVudHJ5ICl7XHJcblx0XHQgIGNhc2UgJ2hvcml6b250YWwnOlxyXG5cdFx0XHRwYXJzZWQub3J0ID0gMDtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHQgIGNhc2UgJ3ZlcnRpY2FsJzpcclxuXHRcdFx0cGFyc2VkLm9ydCA9IDE7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ICBkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnb3JpZW50YXRpb24nIG9wdGlvbiBpcyBpbnZhbGlkLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3RNYXJnaW4gKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggIWlzTnVtZXJpYyhlbnRyeSkgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ21hcmdpbicgb3B0aW9uIG11c3QgYmUgbnVtZXJpYy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkLm1hcmdpbiA9IHBhcnNlZC5zcGVjdHJ1bS5nZXRNYXJnaW4oZW50cnkpO1xyXG5cclxuXHRcdGlmICggIXBhcnNlZC5tYXJnaW4gKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdtYXJnaW4nIG9wdGlvbiBpcyBvbmx5IHN1cHBvcnRlZCBvbiBsaW5lYXIgc2xpZGVycy5cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0TGltaXQgKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdGlmICggIWlzTnVtZXJpYyhlbnRyeSkgKXtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2xpbWl0JyBvcHRpb24gbXVzdCBiZSBudW1lcmljLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRwYXJzZWQubGltaXQgPSBwYXJzZWQuc3BlY3RydW0uZ2V0TWFyZ2luKGVudHJ5KTtcclxuXHJcblx0XHRpZiAoICFwYXJzZWQubGltaXQgKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdsaW1pdCcgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIG9uIGxpbmVhciBzbGlkZXJzLlwiKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHRlc3REaXJlY3Rpb24gKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdC8vIFNldCBkaXJlY3Rpb24gYXMgYSBudW1lcmljYWwgdmFsdWUgZm9yIGVhc3kgcGFyc2luZy5cclxuXHRcdC8vIEludmVydCBjb25uZWN0aW9uIGZvciBSVEwgc2xpZGVycywgc28gdGhhdCB0aGUgcHJvcGVyXHJcblx0XHQvLyBoYW5kbGVzIGdldCB0aGUgY29ubmVjdC9iYWNrZ3JvdW5kIGNsYXNzZXMuXHJcblx0XHRzd2l0Y2ggKCBlbnRyeSApIHtcclxuXHRcdCAgY2FzZSAnbHRyJzpcclxuXHRcdFx0cGFyc2VkLmRpciA9IDA7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ICBjYXNlICdydGwnOlxyXG5cdFx0XHRwYXJzZWQuZGlyID0gMTtcclxuXHRcdFx0cGFyc2VkLmNvbm5lY3QgPSBbMCwyLDEsM11bcGFyc2VkLmNvbm5lY3RdO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdCAgZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwibm9VaVNsaWRlcjogJ2RpcmVjdGlvbicgb3B0aW9uIHdhcyBub3QgcmVjb2duaXplZC5cIik7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0QmVoYXZpb3VyICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHQvLyBNYWtlIHN1cmUgdGhlIGlucHV0IGlzIGEgc3RyaW5nLlxyXG5cdFx0aWYgKCB0eXBlb2YgZW50cnkgIT09ICdzdHJpbmcnICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnYmVoYXZpb3VyJyBtdXN0IGJlIGEgc3RyaW5nIGNvbnRhaW5pbmcgb3B0aW9ucy5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIHN0cmluZyBjb250YWlucyBhbnkga2V5d29yZHMuXHJcblx0XHQvLyBOb25lIGFyZSByZXF1aXJlZC5cclxuXHRcdHZhciB0YXAgPSBlbnRyeS5pbmRleE9mKCd0YXAnKSA+PSAwLFxyXG5cdFx0XHRkcmFnID0gZW50cnkuaW5kZXhPZignZHJhZycpID49IDAsXHJcblx0XHRcdGZpeGVkID0gZW50cnkuaW5kZXhPZignZml4ZWQnKSA+PSAwLFxyXG5cdFx0XHRzbmFwID0gZW50cnkuaW5kZXhPZignc25hcCcpID49IDAsXHJcblx0XHRcdGhvdmVyID0gZW50cnkuaW5kZXhPZignaG92ZXInKSA+PSAwO1xyXG5cclxuXHRcdC8vIEZpeCAjNDcyXHJcblx0XHRpZiAoIGRyYWcgJiYgIXBhcnNlZC5jb25uZWN0ICkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAnZHJhZycgYmVoYXZpb3VyIG11c3QgYmUgdXNlZCB3aXRoICdjb25uZWN0JzogdHJ1ZS5cIik7XHJcblx0XHR9XHJcblxyXG5cdFx0cGFyc2VkLmV2ZW50cyA9IHtcclxuXHRcdFx0dGFwOiB0YXAgfHwgc25hcCxcclxuXHRcdFx0ZHJhZzogZHJhZyxcclxuXHRcdFx0Zml4ZWQ6IGZpeGVkLFxyXG5cdFx0XHRzbmFwOiBzbmFwLFxyXG5cdFx0XHRob3ZlcjogaG92ZXJcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0VG9vbHRpcHMgKCBwYXJzZWQsIGVudHJ5ICkge1xyXG5cclxuXHRcdHZhciBpO1xyXG5cclxuXHRcdGlmICggZW50cnkgPT09IGZhbHNlICkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9IGVsc2UgaWYgKCBlbnRyeSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdHBhcnNlZC50b29sdGlwcyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBwYXJzZWQuaGFuZGxlczsgaSsrICkge1xyXG5cdFx0XHRcdHBhcnNlZC50b29sdGlwcy5wdXNoKHRydWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHBhcnNlZC50b29sdGlwcyA9IGFzQXJyYXkoZW50cnkpO1xyXG5cclxuXHRcdFx0aWYgKCBwYXJzZWQudG9vbHRpcHMubGVuZ3RoICE9PSBwYXJzZWQuaGFuZGxlcyApIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiBtdXN0IHBhc3MgYSBmb3JtYXR0ZXIgZm9yIGFsbCBoYW5kbGVzLlwiKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGFyc2VkLnRvb2x0aXBzLmZvckVhY2goZnVuY3Rpb24oZm9ybWF0dGVyKXtcclxuXHRcdFx0XHRpZiAoIHR5cGVvZiBmb3JtYXR0ZXIgIT09ICdib29sZWFuJyAmJiAodHlwZW9mIGZvcm1hdHRlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIGZvcm1hdHRlci50byAhPT0gJ2Z1bmN0aW9uJykgKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJub1VpU2xpZGVyOiAndG9vbHRpcHMnIG11c3QgYmUgcGFzc2VkIGEgZm9ybWF0dGVyIG9yICdmYWxzZScuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB0ZXN0Rm9ybWF0ICggcGFyc2VkLCBlbnRyeSApIHtcclxuXHJcblx0XHRwYXJzZWQuZm9ybWF0ID0gZW50cnk7XHJcblxyXG5cdFx0Ly8gQW55IG9iamVjdCB3aXRoIGEgdG8gYW5kIGZyb20gbWV0aG9kIGlzIHN1cHBvcnRlZC5cclxuXHRcdGlmICggdHlwZW9mIGVudHJ5LnRvID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBlbnRyeS5mcm9tID09PSAnZnVuY3Rpb24nICkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwibm9VaVNsaWRlcjogJ2Zvcm1hdCcgcmVxdWlyZXMgJ3RvJyBhbmQgJ2Zyb20nIG1ldGhvZHMuXCIpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdGVzdENzc1ByZWZpeCAoIHBhcnNlZCwgZW50cnkgKSB7XHJcblxyXG5cdFx0aWYgKCBlbnRyeSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbnRyeSAhPT0gJ3N0cmluZycgKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvciggXCJub1VpU2xpZGVyOiAnY3NzUHJlZml4JyBtdXN0IGJlIGEgc3RyaW5nLlwiKTtcclxuXHRcdH1cclxuXHJcblx0XHRwYXJzZWQuY3NzUHJlZml4ID0gZW50cnk7XHJcblx0fVxyXG5cclxuXHQvLyBUZXN0IGFsbCBkZXZlbG9wZXIgc2V0dGluZ3MgYW5kIHBhcnNlIHRvIGFzc3VtcHRpb24tc2FmZSB2YWx1ZXMuXHJcblx0ZnVuY3Rpb24gdGVzdE9wdGlvbnMgKCBvcHRpb25zICkge1xyXG5cclxuXHRcdC8vIFRvIHByb3ZlIGEgZml4IGZvciAjNTM3LCBmcmVlemUgb3B0aW9ucyBoZXJlLlxyXG5cdFx0Ly8gSWYgdGhlIG9iamVjdCBpcyBtb2RpZmllZCwgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcblx0XHQvLyBPYmplY3QuZnJlZXplKG9wdGlvbnMpO1xyXG5cclxuXHRcdHZhciBwYXJzZWQgPSB7XHJcblx0XHRcdG1hcmdpbjogMCxcclxuXHRcdFx0bGltaXQ6IDAsXHJcblx0XHRcdGFuaW1hdGU6IHRydWUsXHJcblx0XHRcdGZvcm1hdDogZGVmYXVsdEZvcm1hdHRlclxyXG5cdFx0fSwgdGVzdHM7XHJcblxyXG5cdFx0Ly8gVGVzdHMgYXJlIGV4ZWN1dGVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBwcmVzZW50ZWQgaGVyZS5cclxuXHRcdHRlc3RzID0ge1xyXG5cdFx0XHQnc3RlcCc6IHsgcjogZmFsc2UsIHQ6IHRlc3RTdGVwIH0sXHJcblx0XHRcdCdzdGFydCc6IHsgcjogdHJ1ZSwgdDogdGVzdFN0YXJ0IH0sXHJcblx0XHRcdCdjb25uZWN0JzogeyByOiB0cnVlLCB0OiB0ZXN0Q29ubmVjdCB9LFxyXG5cdFx0XHQnZGlyZWN0aW9uJzogeyByOiB0cnVlLCB0OiB0ZXN0RGlyZWN0aW9uIH0sXHJcblx0XHRcdCdzbmFwJzogeyByOiBmYWxzZSwgdDogdGVzdFNuYXAgfSxcclxuXHRcdFx0J2FuaW1hdGUnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0QW5pbWF0ZSB9LFxyXG5cdFx0XHQncmFuZ2UnOiB7IHI6IHRydWUsIHQ6IHRlc3RSYW5nZSB9LFxyXG5cdFx0XHQnb3JpZW50YXRpb24nOiB7IHI6IGZhbHNlLCB0OiB0ZXN0T3JpZW50YXRpb24gfSxcclxuXHRcdFx0J21hcmdpbic6IHsgcjogZmFsc2UsIHQ6IHRlc3RNYXJnaW4gfSxcclxuXHRcdFx0J2xpbWl0JzogeyByOiBmYWxzZSwgdDogdGVzdExpbWl0IH0sXHJcblx0XHRcdCdiZWhhdmlvdXInOiB7IHI6IHRydWUsIHQ6IHRlc3RCZWhhdmlvdXIgfSxcclxuXHRcdFx0J2Zvcm1hdCc6IHsgcjogZmFsc2UsIHQ6IHRlc3RGb3JtYXQgfSxcclxuXHRcdFx0J3Rvb2x0aXBzJzogeyByOiBmYWxzZSwgdDogdGVzdFRvb2x0aXBzIH0sXHJcblx0XHRcdCdjc3NQcmVmaXgnOiB7IHI6IGZhbHNlLCB0OiB0ZXN0Q3NzUHJlZml4IH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIGRlZmF1bHRzID0ge1xyXG5cdFx0XHQnY29ubmVjdCc6IGZhbHNlLFxyXG5cdFx0XHQnZGlyZWN0aW9uJzogJ2x0cicsXHJcblx0XHRcdCdiZWhhdmlvdXInOiAndGFwJyxcclxuXHRcdFx0J29yaWVudGF0aW9uJzogJ2hvcml6b250YWwnXHJcblx0XHR9O1xyXG5cclxuXHRcdC8vIFJ1biBhbGwgb3B0aW9ucyB0aHJvdWdoIGEgdGVzdGluZyBtZWNoYW5pc20gdG8gZW5zdXJlIGNvcnJlY3RcclxuXHRcdC8vIGlucHV0LiBJdCBzaG91bGQgYmUgbm90ZWQgdGhhdCBvcHRpb25zIG1pZ2h0IGdldCBtb2RpZmllZCB0b1xyXG5cdFx0Ly8gYmUgaGFuZGxlZCBwcm9wZXJseS4gRS5nLiB3cmFwcGluZyBpbnRlZ2VycyBpbiBhcnJheXMuXHJcblx0XHRPYmplY3Qua2V5cyh0ZXN0cykuZm9yRWFjaChmdW5jdGlvbiggbmFtZSApe1xyXG5cclxuXHRcdFx0Ly8gSWYgdGhlIG9wdGlvbiBpc24ndCBzZXQsIGJ1dCBpdCBpcyByZXF1aXJlZCwgdGhyb3cgYW4gZXJyb3IuXHJcblx0XHRcdGlmICggb3B0aW9uc1tuYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRzW25hbWVdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggdGVzdHNbbmFtZV0uciApIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIm5vVWlTbGlkZXI6ICdcIiArIG5hbWUgKyBcIicgaXMgcmVxdWlyZWQuXCIpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRlc3RzW25hbWVdLnQoIHBhcnNlZCwgb3B0aW9uc1tuYW1lXSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdHNbbmFtZV0gOiBvcHRpb25zW25hbWVdICk7XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBGb3J3YXJkIHBpcHMgb3B0aW9uc1xyXG5cdFx0cGFyc2VkLnBpcHMgPSBvcHRpb25zLnBpcHM7XHJcblxyXG5cdFx0Ly8gUHJlLWRlZmluZSB0aGUgc3R5bGVzLlxyXG5cdFx0cGFyc2VkLnN0eWxlID0gcGFyc2VkLm9ydCA/ICd0b3AnIDogJ2xlZnQnO1xyXG5cclxuXHRcdHJldHVybiBwYXJzZWQ7XHJcblx0fVxyXG5cclxuXHJcbmZ1bmN0aW9uIGNsb3N1cmUgKCB0YXJnZXQsIG9wdGlvbnMgKXtcclxuXHJcblx0Ly8gQWxsIHZhcmlhYmxlcyBsb2NhbCB0byAnY2xvc3VyZScgYXJlIHByZWZpeGVkIHdpdGggJ3Njb3BlXydcclxuXHR2YXIgc2NvcGVfVGFyZ2V0ID0gdGFyZ2V0LFxyXG5cdFx0c2NvcGVfTG9jYXRpb25zID0gWy0xLCAtMV0sXHJcblx0XHRzY29wZV9CYXNlLFxyXG5cdFx0c2NvcGVfSGFuZGxlcyxcclxuXHRcdHNjb3BlX1NwZWN0cnVtID0gb3B0aW9ucy5zcGVjdHJ1bSxcclxuXHRcdHNjb3BlX1ZhbHVlcyA9IFtdLFxyXG5cdFx0c2NvcGVfRXZlbnRzID0ge30sXHJcblx0XHRzY29wZV9TZWxmO1xyXG5cclxuICB2YXIgY3NzQ2xhc3NlcyA9IFtcclxuICAgIC8qICAwICovICAndGFyZ2V0J1xyXG4gICAgLyogIDEgKi8gLCdiYXNlJ1xyXG4gICAgLyogIDIgKi8gLCdvcmlnaW4nXHJcbiAgICAvKiAgMyAqLyAsJ2hhbmRsZSdcclxuICAgIC8qICA0ICovICwnaG9yaXpvbnRhbCdcclxuICAgIC8qICA1ICovICwndmVydGljYWwnXHJcbiAgICAvKiAgNiAqLyAsJ2JhY2tncm91bmQnXHJcbiAgICAvKiAgNyAqLyAsJ2Nvbm5lY3QnXHJcbiAgICAvKiAgOCAqLyAsJ2x0cidcclxuICAgIC8qICA5ICovICwncnRsJ1xyXG4gICAgLyogMTAgKi8gLCdkcmFnZ2FibGUnXHJcbiAgICAvKiAxMSAqLyAsJydcclxuICAgIC8qIDEyICovICwnc3RhdGUtZHJhZydcclxuICAgIC8qIDEzICovICwnJ1xyXG4gICAgLyogMTQgKi8gLCdzdGF0ZS10YXAnXHJcbiAgICAvKiAxNSAqLyAsJ2FjdGl2ZSdcclxuICAgIC8qIDE2ICovICwnJ1xyXG4gICAgLyogMTcgKi8gLCdzdGFja2luZydcclxuICAgIC8qIDE4ICovICwndG9vbHRpcCdcclxuICAgIC8qIDE5ICovICwnJ1xyXG4gICAgLyogMjAgKi8gLCdwaXBzJ1xyXG4gICAgLyogMjEgKi8gLCdtYXJrZXInXHJcbiAgICAvKiAyMiAqLyAsJ3ZhbHVlJ1xyXG4gIF0ubWFwKGFkZENzc1ByZWZpeChvcHRpb25zLmNzc1ByZWZpeCB8fCBkZWZhdWx0Q3NzUHJlZml4KSk7XHJcblxyXG5cclxuXHQvLyBEZWxpbWl0IHByb3Bvc2VkIHZhbHVlcyBmb3IgaGFuZGxlIHBvc2l0aW9ucy5cclxuXHRmdW5jdGlvbiBnZXRQb3NpdGlvbnMgKCBhLCBiLCBkZWxpbWl0ICkge1xyXG5cclxuXHRcdC8vIEFkZCBtb3ZlbWVudCB0byBjdXJyZW50IHBvc2l0aW9uLlxyXG5cdFx0dmFyIGMgPSBhICsgYlswXSwgZCA9IGEgKyBiWzFdO1xyXG5cclxuXHRcdC8vIE9ubHkgYWx0ZXIgdGhlIG90aGVyIHBvc2l0aW9uIG9uIGRyYWcsXHJcblx0XHQvLyBub3Qgb24gc3RhbmRhcmQgc2xpZGluZy5cclxuXHRcdGlmICggZGVsaW1pdCApIHtcclxuXHRcdFx0aWYgKCBjIDwgMCApIHtcclxuXHRcdFx0XHRkICs9IE1hdGguYWJzKGMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICggZCA+IDEwMCApIHtcclxuXHRcdFx0XHRjIC09ICggZCAtIDEwMCApO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBMaW1pdCB2YWx1ZXMgdG8gMCBhbmQgMTAwLlxyXG5cdFx0XHRyZXR1cm4gW2xpbWl0KGMpLCBsaW1pdChkKV07XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIFtjLGRdO1xyXG5cdH1cclxuXHJcblx0Ly8gUHJvdmlkZSBhIGNsZWFuIGV2ZW50IHdpdGggc3RhbmRhcmRpemVkIG9mZnNldCB2YWx1ZXMuXHJcblx0ZnVuY3Rpb24gZml4RXZlbnQgKCBlLCBwYWdlT2Zmc2V0ICkge1xyXG5cclxuXHRcdC8vIFByZXZlbnQgc2Nyb2xsaW5nIGFuZCBwYW5uaW5nIG9uIHRvdWNoIGV2ZW50cywgd2hpbGVcclxuXHRcdC8vIGF0dGVtcHRpbmcgdG8gc2xpZGUuIFRoZSB0YXAgZXZlbnQgYWxzbyBkZXBlbmRzIG9uIHRoaXMuXHJcblx0XHRlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0Ly8gRmlsdGVyIHRoZSBldmVudCB0byByZWdpc3RlciB0aGUgdHlwZSwgd2hpY2ggY2FuIGJlXHJcblx0XHQvLyB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlci4gT2Zmc2V0IGNoYW5nZXMgbmVlZCB0byBiZVxyXG5cdFx0Ly8gbWFkZSBvbiBhbiBldmVudCBzcGVjaWZpYyBiYXNpcy5cclxuXHRcdHZhciB0b3VjaCA9IGUudHlwZS5pbmRleE9mKCd0b3VjaCcpID09PSAwLFxyXG5cdFx0XHRtb3VzZSA9IGUudHlwZS5pbmRleE9mKCdtb3VzZScpID09PSAwLFxyXG5cdFx0XHRwb2ludGVyID0gZS50eXBlLmluZGV4T2YoJ3BvaW50ZXInKSA9PT0gMCxcclxuXHRcdFx0eCx5LCBldmVudCA9IGU7XHJcblxyXG5cdFx0Ly8gSUUxMCBpbXBsZW1lbnRlZCBwb2ludGVyIGV2ZW50cyB3aXRoIGEgcHJlZml4O1xyXG5cdFx0aWYgKCBlLnR5cGUuaW5kZXhPZignTVNQb2ludGVyJykgPT09IDAgKSB7XHJcblx0XHRcdHBvaW50ZXIgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdG91Y2ggKSB7XHJcblx0XHRcdC8vIG5vVWlTbGlkZXIgc3VwcG9ydHMgb25lIG1vdmVtZW50IGF0IGEgdGltZSxcclxuXHRcdFx0Ly8gc28gd2UgY2FuIHNlbGVjdCB0aGUgZmlyc3QgJ2NoYW5nZWRUb3VjaCcuXHJcblx0XHRcdHggPSBlLmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYO1xyXG5cdFx0XHR5ID0gZS5jaGFuZ2VkVG91Y2hlc1swXS5wYWdlWTtcclxuXHRcdH1cclxuXHJcblx0XHRwYWdlT2Zmc2V0ID0gcGFnZU9mZnNldCB8fCBnZXRQYWdlT2Zmc2V0KCk7XHJcblxyXG5cdFx0aWYgKCBtb3VzZSB8fCBwb2ludGVyICkge1xyXG5cdFx0XHR4ID0gZS5jbGllbnRYICsgcGFnZU9mZnNldC54O1xyXG5cdFx0XHR5ID0gZS5jbGllbnRZICsgcGFnZU9mZnNldC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdGV2ZW50LnBhZ2VPZmZzZXQgPSBwYWdlT2Zmc2V0O1xyXG5cdFx0ZXZlbnQucG9pbnRzID0gW3gsIHldO1xyXG5cdFx0ZXZlbnQuY3Vyc29yID0gbW91c2UgfHwgcG9pbnRlcjsgLy8gRml4ICM0MzVcclxuXHJcblx0XHRyZXR1cm4gZXZlbnQ7XHJcblx0fVxyXG5cclxuXHQvLyBBcHBlbmQgYSBoYW5kbGUgdG8gdGhlIGJhc2UuXHJcblx0ZnVuY3Rpb24gYWRkSGFuZGxlICggZGlyZWN0aW9uLCBpbmRleCApIHtcclxuXHJcblx0XHR2YXIgb3JpZ2luID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXHJcblx0XHRcdGhhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxyXG5cdFx0XHRhZGRpdGlvbnMgPSBbICctbG93ZXInLCAnLXVwcGVyJyBdO1xyXG5cclxuXHRcdGlmICggZGlyZWN0aW9uICkge1xyXG5cdFx0XHRhZGRpdGlvbnMucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGFkZENsYXNzKGhhbmRsZSwgY3NzQ2xhc3Nlc1szXSk7XHJcblx0XHRhZGRDbGFzcyhoYW5kbGUsIGNzc0NsYXNzZXNbM10gKyBhZGRpdGlvbnNbaW5kZXhdKTtcclxuXHJcblx0XHRhZGRDbGFzcyhvcmlnaW4sIGNzc0NsYXNzZXNbMl0pO1xyXG5cdFx0b3JpZ2luLmFwcGVuZENoaWxkKGhhbmRsZSk7XHJcblxyXG5cdFx0cmV0dXJuIG9yaWdpbjtcclxuXHR9XHJcblxyXG5cdC8vIEFkZCB0aGUgcHJvcGVyIGNvbm5lY3Rpb24gY2xhc3Nlcy5cclxuXHRmdW5jdGlvbiBhZGRDb25uZWN0aW9uICggY29ubmVjdCwgdGFyZ2V0LCBoYW5kbGVzICkge1xyXG5cclxuXHRcdC8vIEFwcGx5IHRoZSByZXF1aXJlZCBjb25uZWN0aW9uIGNsYXNzZXMgdG8gdGhlIGVsZW1lbnRzXHJcblx0XHQvLyB0aGF0IG5lZWQgdGhlbS4gU29tZSBjbGFzc2VzIGFyZSBtYWRlIHVwIGZvciBzZXZlcmFsXHJcblx0XHQvLyBzZWdtZW50cyBsaXN0ZWQgaW4gdGhlIGNsYXNzIGxpc3QsIHRvIGFsbG93IGVhc3lcclxuXHRcdC8vIHJlbmFtaW5nIGFuZCBwcm92aWRlIGEgbWlub3IgY29tcHJlc3Npb24gYmVuZWZpdC5cclxuXHRcdHN3aXRjaCAoIGNvbm5lY3QgKSB7XHJcblx0XHRcdGNhc2UgMTpcdGFkZENsYXNzKHRhcmdldCwgY3NzQ2xhc3Nlc1s3XSk7XHJcblx0XHRcdFx0XHRhZGRDbGFzcyhoYW5kbGVzWzBdLCBjc3NDbGFzc2VzWzZdKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlIDM6IGFkZENsYXNzKGhhbmRsZXNbMV0sIGNzc0NsYXNzZXNbNl0pO1xyXG5cdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cdFx0XHRjYXNlIDI6IGFkZENsYXNzKGhhbmRsZXNbMF0sIGNzc0NsYXNzZXNbN10pO1xyXG5cdFx0XHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xyXG5cdFx0XHRjYXNlIDA6IGFkZENsYXNzKHRhcmdldCwgY3NzQ2xhc3Nlc1s2XSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIEFkZCBoYW5kbGVzIHRvIHRoZSBzbGlkZXIgYmFzZS5cclxuXHRmdW5jdGlvbiBhZGRIYW5kbGVzICggbnJIYW5kbGVzLCBkaXJlY3Rpb24sIGJhc2UgKSB7XHJcblxyXG5cdFx0dmFyIGluZGV4LCBoYW5kbGVzID0gW107XHJcblxyXG5cdFx0Ly8gQXBwZW5kIGhhbmRsZXMuXHJcblx0XHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbnJIYW5kbGVzOyBpbmRleCArPSAxICkge1xyXG5cclxuXHRcdFx0Ly8gS2VlcCBhIGxpc3Qgb2YgYWxsIGFkZGVkIGhhbmRsZXMuXHJcblx0XHRcdGhhbmRsZXMucHVzaCggYmFzZS5hcHBlbmRDaGlsZChhZGRIYW5kbGUoIGRpcmVjdGlvbiwgaW5kZXggKSkgKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaGFuZGxlcztcclxuXHR9XHJcblxyXG5cdC8vIEluaXRpYWxpemUgYSBzaW5nbGUgc2xpZGVyLlxyXG5cdGZ1bmN0aW9uIGFkZFNsaWRlciAoIGRpcmVjdGlvbiwgb3JpZW50YXRpb24sIHRhcmdldCApIHtcclxuXHJcblx0XHQvLyBBcHBseSBjbGFzc2VzIGFuZCBkYXRhIHRvIHRoZSB0YXJnZXQuXHJcblx0XHRhZGRDbGFzcyh0YXJnZXQsIGNzc0NsYXNzZXNbMF0pO1xyXG5cdFx0YWRkQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzWzggKyBkaXJlY3Rpb25dKTtcclxuXHRcdGFkZENsYXNzKHRhcmdldCwgY3NzQ2xhc3Nlc1s0ICsgb3JpZW50YXRpb25dKTtcclxuXHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRhZGRDbGFzcyhkaXYsIGNzc0NsYXNzZXNbMV0pO1xyXG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKGRpdik7XHJcblx0XHRyZXR1cm4gZGl2O1xyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIGFkZFRvb2x0aXAgKCBoYW5kbGUsIGluZGV4ICkge1xyXG5cclxuXHRcdGlmICggIW9wdGlvbnMudG9vbHRpcHNbaW5kZXhdICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdGVsZW1lbnQuY2xhc3NOYW1lID0gY3NzQ2xhc3Nlc1sxOF07XHJcblx0XHRyZXR1cm4gaGFuZGxlLmZpcnN0Q2hpbGQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XHJcblx0fVxyXG5cclxuXHQvLyBUaGUgdG9vbHRpcHMgb3B0aW9uIGlzIGEgc2hvcnRoYW5kIGZvciB1c2luZyB0aGUgJ3VwZGF0ZScgZXZlbnQuXHJcblx0ZnVuY3Rpb24gdG9vbHRpcHMgKCApIHtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuZGlyICkge1xyXG5cdFx0XHRvcHRpb25zLnRvb2x0aXBzLnJldmVyc2UoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUb29sdGlwcyBhcmUgYWRkZWQgd2l0aCBvcHRpb25zLnRvb2x0aXBzIGluIG9yaWdpbmFsIG9yZGVyLlxyXG5cdFx0dmFyIHRpcHMgPSBzY29wZV9IYW5kbGVzLm1hcChhZGRUb29sdGlwKTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuZGlyICkge1xyXG5cdFx0XHR0aXBzLnJldmVyc2UoKTtcclxuXHRcdFx0b3B0aW9ucy50b29sdGlwcy5yZXZlcnNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0YmluZEV2ZW50KCd1cGRhdGUnLCBmdW5jdGlvbihmLCBvLCByKSB7XHJcblx0XHRcdGlmICggdGlwc1tvXSApIHtcclxuXHRcdFx0XHR0aXBzW29dLmlubmVySFRNTCA9IG9wdGlvbnMudG9vbHRpcHNbb10gPT09IHRydWUgPyBmW29dIDogb3B0aW9ucy50b29sdGlwc1tvXS50byhyW29dKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fVxyXG5cclxuXHJcblx0ZnVuY3Rpb24gZ2V0R3JvdXAgKCBtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQgKSB7XHJcblxyXG5cdFx0Ly8gVXNlIHRoZSByYW5nZS5cclxuXHRcdGlmICggbW9kZSA9PT0gJ3JhbmdlJyB8fCBtb2RlID09PSAnc3RlcHMnICkge1xyXG5cdFx0XHRyZXR1cm4gc2NvcGVfU3BlY3RydW0ueFZhbDtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1vZGUgPT09ICdjb3VudCcgKSB7XHJcblxyXG5cdFx0XHQvLyBEaXZpZGUgMCAtIDEwMCBpbiAnY291bnQnIHBhcnRzLlxyXG5cdFx0XHR2YXIgc3ByZWFkID0gKCAxMDAgLyAodmFsdWVzLTEpICksIHYsIGkgPSAwO1xyXG5cdFx0XHR2YWx1ZXMgPSBbXTtcclxuXHJcblx0XHRcdC8vIExpc3QgdGhlc2UgcGFydHMgYW5kIGhhdmUgdGhlbSBoYW5kbGVkIGFzICdwb3NpdGlvbnMnLlxyXG5cdFx0XHR3aGlsZSAoKHY9aSsrKnNwcmVhZCkgPD0gMTAwICkge1xyXG5cdFx0XHRcdHZhbHVlcy5wdXNoKHYpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRtb2RlID0gJ3Bvc2l0aW9ucyc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtb2RlID09PSAncG9zaXRpb25zJyApIHtcclxuXHJcblx0XHRcdC8vIE1hcCBhbGwgcGVyY2VudGFnZXMgdG8gb24tcmFuZ2UgdmFsdWVzLlxyXG5cdFx0XHRyZXR1cm4gdmFsdWVzLm1hcChmdW5jdGlvbiggdmFsdWUgKXtcclxuXHRcdFx0XHRyZXR1cm4gc2NvcGVfU3BlY3RydW0uZnJvbVN0ZXBwaW5nKCBzdGVwcGVkID8gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCggdmFsdWUgKSA6IHZhbHVlICk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbW9kZSA9PT0gJ3ZhbHVlcycgKSB7XHJcblxyXG5cdFx0XHQvLyBJZiB0aGUgdmFsdWUgbXVzdCBiZSBzdGVwcGVkLCBpdCBuZWVkcyB0byBiZSBjb252ZXJ0ZWQgdG8gYSBwZXJjZW50YWdlIGZpcnN0LlxyXG5cdFx0XHRpZiAoIHN0ZXBwZWQgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiB2YWx1ZXMubWFwKGZ1bmN0aW9uKCB2YWx1ZSApe1xyXG5cclxuXHRcdFx0XHRcdC8vIENvbnZlcnQgdG8gcGVyY2VudGFnZSwgYXBwbHkgc3RlcCwgcmV0dXJuIHRvIHZhbHVlLlxyXG5cdFx0XHRcdFx0cmV0dXJuIHNjb3BlX1NwZWN0cnVtLmZyb21TdGVwcGluZyggc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCggc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyggdmFsdWUgKSApICk7XHJcblx0XHRcdFx0fSk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBPdGhlcndpc2UsIHdlIGNhbiBzaW1wbHkgdXNlIHRoZSB2YWx1ZXMuXHJcblx0XHRcdHJldHVybiB2YWx1ZXM7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZW5lcmF0ZVNwcmVhZCAoIGRlbnNpdHksIG1vZGUsIGdyb3VwICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIHNhZmVJbmNyZW1lbnQodmFsdWUsIGluY3JlbWVudCkge1xyXG5cdFx0XHQvLyBBdm9pZCBmbG9hdGluZyBwb2ludCB2YXJpYW5jZSBieSBkcm9wcGluZyB0aGUgc21hbGxlc3QgZGVjaW1hbCBwbGFjZXMuXHJcblx0XHRcdHJldHVybiAodmFsdWUgKyBpbmNyZW1lbnQpLnRvRml4ZWQoNykgLyAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcmlnaW5hbFNwZWN0cnVtRGlyZWN0aW9uID0gc2NvcGVfU3BlY3RydW0uZGlyZWN0aW9uLFxyXG5cdFx0XHRpbmRleGVzID0ge30sXHJcblx0XHRcdGZpcnN0SW5SYW5nZSA9IHNjb3BlX1NwZWN0cnVtLnhWYWxbMF0sXHJcblx0XHRcdGxhc3RJblJhbmdlID0gc2NvcGVfU3BlY3RydW0ueFZhbFtzY29wZV9TcGVjdHJ1bS54VmFsLmxlbmd0aC0xXSxcclxuXHRcdFx0aWdub3JlRmlyc3QgPSBmYWxzZSxcclxuXHRcdFx0aWdub3JlTGFzdCA9IGZhbHNlLFxyXG5cdFx0XHRwcmV2UGN0ID0gMDtcclxuXHJcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIGxvb3BzIHRoZSBzcGVjdHJ1bSBpbiBhbiBsdHIgbGluZWFyIGZhc2hpb24sXHJcblx0XHQvLyB3aGlsZSB0aGUgdG9TdGVwcGluZyBtZXRob2QgaXMgZGlyZWN0aW9uIGF3YXJlLiBUcmljayBpdCBpbnRvXHJcblx0XHQvLyBiZWxpZXZpbmcgaXQgaXMgbHRyLlxyXG5cdFx0c2NvcGVfU3BlY3RydW0uZGlyZWN0aW9uID0gMDtcclxuXHJcblx0XHQvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBncm91cCwgc29ydCBpdCBhbmQgZmlsdGVyIGF3YXkgYWxsIGR1cGxpY2F0ZXMuXHJcblx0XHRncm91cCA9IHVuaXF1ZShncm91cC5zbGljZSgpLnNvcnQoZnVuY3Rpb24oYSwgYil7IHJldHVybiBhIC0gYjsgfSkpO1xyXG5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgcmFuZ2Ugc3RhcnRzIHdpdGggdGhlIGZpcnN0IGVsZW1lbnQuXHJcblx0XHRpZiAoIGdyb3VwWzBdICE9PSBmaXJzdEluUmFuZ2UgKSB7XHJcblx0XHRcdGdyb3VwLnVuc2hpZnQoZmlyc3RJblJhbmdlKTtcclxuXHRcdFx0aWdub3JlRmlyc3QgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIExpa2V3aXNlIGZvciB0aGUgbGFzdCBvbmUuXHJcblx0XHRpZiAoIGdyb3VwW2dyb3VwLmxlbmd0aCAtIDFdICE9PSBsYXN0SW5SYW5nZSApIHtcclxuXHRcdFx0Z3JvdXAucHVzaChsYXN0SW5SYW5nZSk7XHJcblx0XHRcdGlnbm9yZUxhc3QgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGdyb3VwLmZvckVhY2goZnVuY3Rpb24gKCBjdXJyZW50LCBpbmRleCApIHtcclxuXHJcblx0XHRcdC8vIEdldCB0aGUgY3VycmVudCBzdGVwIGFuZCB0aGUgbG93ZXIgKyB1cHBlciBwb3NpdGlvbnMuXHJcblx0XHRcdHZhciBzdGVwLCBpLCBxLFxyXG5cdFx0XHRcdGxvdyA9IGN1cnJlbnQsXHJcblx0XHRcdFx0aGlnaCA9IGdyb3VwW2luZGV4KzFdLFxyXG5cdFx0XHRcdG5ld1BjdCwgcGN0RGlmZmVyZW5jZSwgcGN0UG9zLCB0eXBlLFxyXG5cdFx0XHRcdHN0ZXBzLCByZWFsU3RlcHMsIHN0ZXBzaXplO1xyXG5cclxuXHRcdFx0Ly8gV2hlbiB1c2luZyAnc3RlcHMnIG1vZGUsIHVzZSB0aGUgcHJvdmlkZWQgc3RlcHMuXHJcblx0XHRcdC8vIE90aGVyd2lzZSwgd2UnbGwgc3RlcCBvbiB0byB0aGUgbmV4dCBzdWJyYW5nZS5cclxuXHRcdFx0aWYgKCBtb2RlID09PSAnc3RlcHMnICkge1xyXG5cdFx0XHRcdHN0ZXAgPSBzY29wZV9TcGVjdHJ1bS54TnVtU3RlcHNbIGluZGV4IF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIERlZmF1bHQgdG8gYSAnZnVsbCcgc3RlcC5cclxuXHRcdFx0aWYgKCAhc3RlcCApIHtcclxuXHRcdFx0XHRzdGVwID0gaGlnaC1sb3c7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIExvdyBjYW4gYmUgMCwgc28gdGVzdCBmb3IgZmFsc2UuIElmIGhpZ2ggaXMgdW5kZWZpbmVkLFxyXG5cdFx0XHQvLyB3ZSBhcmUgYXQgdGhlIGxhc3Qgc3VicmFuZ2UuIEluZGV4IDAgaXMgYWxyZWFkeSBoYW5kbGVkLlxyXG5cdFx0XHRpZiAoIGxvdyA9PT0gZmFsc2UgfHwgaGlnaCA9PT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRmluZCBhbGwgc3RlcHMgaW4gdGhlIHN1YnJhbmdlLlxyXG5cdFx0XHRmb3IgKCBpID0gbG93OyBpIDw9IGhpZ2g7IGkgPSBzYWZlSW5jcmVtZW50KGksIHN0ZXApICkge1xyXG5cclxuXHRcdFx0XHQvLyBHZXQgdGhlIHBlcmNlbnRhZ2UgdmFsdWUgZm9yIHRoZSBjdXJyZW50IHN0ZXAsXHJcblx0XHRcdFx0Ly8gY2FsY3VsYXRlIHRoZSBzaXplIGZvciB0aGUgc3VicmFuZ2UuXHJcblx0XHRcdFx0bmV3UGN0ID0gc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyggaSApO1xyXG5cdFx0XHRcdHBjdERpZmZlcmVuY2UgPSBuZXdQY3QgLSBwcmV2UGN0O1xyXG5cclxuXHRcdFx0XHRzdGVwcyA9IHBjdERpZmZlcmVuY2UgLyBkZW5zaXR5O1xyXG5cdFx0XHRcdHJlYWxTdGVwcyA9IE1hdGgucm91bmQoc3RlcHMpO1xyXG5cclxuXHRcdFx0XHQvLyBUaGlzIHJhdGlvIHJlcHJlc2VudHMgdGhlIGFtbW91bnQgb2YgcGVyY2VudGFnZS1zcGFjZSBhIHBvaW50IGluZGljYXRlcy5cclxuXHRcdFx0XHQvLyBGb3IgYSBkZW5zaXR5IDEgdGhlIHBvaW50cy9wZXJjZW50YWdlID0gMS4gRm9yIGRlbnNpdHkgMiwgdGhhdCBwZXJjZW50YWdlIG5lZWRzIHRvIGJlIHJlLWRldmlkZWQuXHJcblx0XHRcdFx0Ly8gUm91bmQgdGhlIHBlcmNlbnRhZ2Ugb2Zmc2V0IHRvIGFuIGV2ZW4gbnVtYmVyLCB0aGVuIGRpdmlkZSBieSB0d29cclxuXHRcdFx0XHQvLyB0byBzcHJlYWQgdGhlIG9mZnNldCBvbiBib3RoIHNpZGVzIG9mIHRoZSByYW5nZS5cclxuXHRcdFx0XHRzdGVwc2l6ZSA9IHBjdERpZmZlcmVuY2UvcmVhbFN0ZXBzO1xyXG5cclxuXHRcdFx0XHQvLyBEaXZpZGUgYWxsIHBvaW50cyBldmVubHksIGFkZGluZyB0aGUgY29ycmVjdCBudW1iZXIgdG8gdGhpcyBzdWJyYW5nZS5cclxuXHRcdFx0XHQvLyBSdW4gdXAgdG8gPD0gc28gdGhhdCAxMDAlIGdldHMgYSBwb2ludCwgZXZlbnQgaWYgaWdub3JlTGFzdCBpcyBzZXQuXHJcblx0XHRcdFx0Zm9yICggcSA9IDE7IHEgPD0gcmVhbFN0ZXBzOyBxICs9IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0Ly8gVGhlIHJhdGlvIGJldHdlZW4gdGhlIHJvdW5kZWQgdmFsdWUgYW5kIHRoZSBhY3R1YWwgc2l6ZSBtaWdodCBiZSB+MSUgb2ZmLlxyXG5cdFx0XHRcdFx0Ly8gQ29ycmVjdCB0aGUgcGVyY2VudGFnZSBvZmZzZXQgYnkgdGhlIG51bWJlciBvZiBwb2ludHNcclxuXHRcdFx0XHRcdC8vIHBlciBzdWJyYW5nZS4gZGVuc2l0eSA9IDEgd2lsbCByZXN1bHQgaW4gMTAwIHBvaW50cyBvbiB0aGVcclxuXHRcdFx0XHRcdC8vIGZ1bGwgcmFuZ2UsIDIgZm9yIDUwLCA0IGZvciAyNSwgZXRjLlxyXG5cdFx0XHRcdFx0cGN0UG9zID0gcHJldlBjdCArICggcSAqIHN0ZXBzaXplICk7XHJcblx0XHRcdFx0XHRpbmRleGVzW3BjdFBvcy50b0ZpeGVkKDUpXSA9IFsneCcsIDBdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gRGV0ZXJtaW5lIHRoZSBwb2ludCB0eXBlLlxyXG5cdFx0XHRcdHR5cGUgPSAoZ3JvdXAuaW5kZXhPZihpKSA+IC0xKSA/IDEgOiAoIG1vZGUgPT09ICdzdGVwcycgPyAyIDogMCApO1xyXG5cclxuXHRcdFx0XHQvLyBFbmZvcmNlIHRoZSAnaWdub3JlRmlyc3QnIG9wdGlvbiBieSBvdmVyd3JpdGluZyB0aGUgdHlwZSBmb3IgMC5cclxuXHRcdFx0XHRpZiAoICFpbmRleCAmJiBpZ25vcmVGaXJzdCApIHtcclxuXHRcdFx0XHRcdHR5cGUgPSAwO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCAhKGkgPT09IGhpZ2ggJiYgaWdub3JlTGFzdCkpIHtcclxuXHRcdFx0XHRcdC8vIE1hcmsgdGhlICd0eXBlJyBvZiB0aGlzIHBvaW50LiAwID0gcGxhaW4sIDEgPSByZWFsIHZhbHVlLCAyID0gc3RlcCB2YWx1ZS5cclxuXHRcdFx0XHRcdGluZGV4ZXNbbmV3UGN0LnRvRml4ZWQoNSldID0gW2ksIHR5cGVdO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSBwZXJjZW50YWdlIGNvdW50LlxyXG5cdFx0XHRcdHByZXZQY3QgPSBuZXdQY3Q7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFJlc2V0IHRoZSBzcGVjdHJ1bS5cclxuXHRcdHNjb3BlX1NwZWN0cnVtLmRpcmVjdGlvbiA9IG9yaWdpbmFsU3BlY3RydW1EaXJlY3Rpb247XHJcblxyXG5cdFx0cmV0dXJuIGluZGV4ZXM7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBhZGRNYXJraW5nICggc3ByZWFkLCBmaWx0ZXJGdW5jLCBmb3JtYXR0ZXIgKSB7XHJcblxyXG5cdFx0dmFyIHN0eWxlID0gWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ11bb3B0aW9ucy5vcnRdLFxyXG5cdFx0XHRlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblxyXG5cdFx0YWRkQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3Nlc1syMF0pO1xyXG5cdFx0YWRkQ2xhc3MoZWxlbWVudCwgY3NzQ2xhc3Nlc1syMF0gKyAnLScgKyBzdHlsZSk7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZ2V0U2l6ZSggdHlwZSApe1xyXG5cdFx0XHRyZXR1cm4gWyAnLW5vcm1hbCcsICctbGFyZ2UnLCAnLXN1YicgXVt0eXBlXTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBnZXRUYWdzKCBvZmZzZXQsIHNvdXJjZSwgdmFsdWVzICkge1xyXG5cdFx0XHRyZXR1cm4gJ2NsYXNzPVwiJyArIHNvdXJjZSArICcgJyArXHJcblx0XHRcdFx0c291cmNlICsgJy0nICsgc3R5bGUgKyAnICcgK1xyXG5cdFx0XHRcdHNvdXJjZSArIGdldFNpemUodmFsdWVzWzFdKSArXHJcblx0XHRcdFx0J1wiIHN0eWxlPVwiJyArIG9wdGlvbnMuc3R5bGUgKyAnOiAnICsgb2Zmc2V0ICsgJyVcIic7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gYWRkU3ByZWFkICggb2Zmc2V0LCB2YWx1ZXMgKXtcclxuXHJcblx0XHRcdGlmICggc2NvcGVfU3BlY3RydW0uZGlyZWN0aW9uICkge1xyXG5cdFx0XHRcdG9mZnNldCA9IDEwMCAtIG9mZnNldDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQXBwbHkgdGhlIGZpbHRlciBmdW5jdGlvbiwgaWYgaXQgaXMgc2V0LlxyXG5cdFx0XHR2YWx1ZXNbMV0gPSAodmFsdWVzWzFdICYmIGZpbHRlckZ1bmMpID8gZmlsdGVyRnVuYyh2YWx1ZXNbMF0sIHZhbHVlc1sxXSkgOiB2YWx1ZXNbMV07XHJcblxyXG5cdFx0XHQvLyBBZGQgYSBtYXJrZXIgZm9yIGV2ZXJ5IHBvaW50XHJcblx0XHRcdGVsZW1lbnQuaW5uZXJIVE1MICs9ICc8ZGl2ICcgKyBnZXRUYWdzKG9mZnNldCwgY3NzQ2xhc3Nlc1syMV0sIHZhbHVlcykgKyAnPjwvZGl2Pic7XHJcblxyXG5cdFx0XHQvLyBWYWx1ZXMgYXJlIG9ubHkgYXBwZW5kZWQgZm9yIHBvaW50cyBtYXJrZWQgJzEnIG9yICcyJy5cclxuXHRcdFx0aWYgKCB2YWx1ZXNbMV0gKSB7XHJcblx0XHRcdFx0ZWxlbWVudC5pbm5lckhUTUwgKz0gJzxkaXYgJytnZXRUYWdzKG9mZnNldCwgY3NzQ2xhc3Nlc1syMl0sIHZhbHVlcykrJz4nICsgZm9ybWF0dGVyLnRvKHZhbHVlc1swXSkgKyAnPC9kaXY+JztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFwcGVuZCBhbGwgcG9pbnRzLlxyXG5cdFx0T2JqZWN0LmtleXMoc3ByZWFkKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe1xyXG5cdFx0XHRhZGRTcHJlYWQoYSwgc3ByZWFkW2FdKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBlbGVtZW50O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGlwcyAoIGdyaWQgKSB7XHJcblxyXG5cdHZhciBtb2RlID0gZ3JpZC5tb2RlLFxyXG5cdFx0ZGVuc2l0eSA9IGdyaWQuZGVuc2l0eSB8fCAxLFxyXG5cdFx0ZmlsdGVyID0gZ3JpZC5maWx0ZXIgfHwgZmFsc2UsXHJcblx0XHR2YWx1ZXMgPSBncmlkLnZhbHVlcyB8fCBmYWxzZSxcclxuXHRcdHN0ZXBwZWQgPSBncmlkLnN0ZXBwZWQgfHwgZmFsc2UsXHJcblx0XHRncm91cCA9IGdldEdyb3VwKCBtb2RlLCB2YWx1ZXMsIHN0ZXBwZWQgKSxcclxuXHRcdHNwcmVhZCA9IGdlbmVyYXRlU3ByZWFkKCBkZW5zaXR5LCBtb2RlLCBncm91cCApLFxyXG5cdFx0Zm9ybWF0ID0gZ3JpZC5mb3JtYXQgfHwge1xyXG5cdFx0XHR0bzogTWF0aC5yb3VuZFxyXG5cdFx0fTtcclxuXHJcblx0XHRyZXR1cm4gc2NvcGVfVGFyZ2V0LmFwcGVuZENoaWxkKGFkZE1hcmtpbmcoXHJcblx0XHRcdHNwcmVhZCxcclxuXHRcdFx0ZmlsdGVyLFxyXG5cdFx0XHRmb3JtYXRcclxuXHRcdCkpO1xyXG5cdH1cclxuXHJcblxyXG5cdC8vIFNob3J0aGFuZCBmb3IgYmFzZSBkaW1lbnNpb25zLlxyXG5cdGZ1bmN0aW9uIGJhc2VTaXplICggKSB7XHJcblx0XHRyZXR1cm4gc2NvcGVfQmFzZVsnb2Zmc2V0JyArIFsnV2lkdGgnLCAnSGVpZ2h0J11bb3B0aW9ucy5vcnRdXTtcclxuXHR9XHJcblxyXG5cdC8vIEV4dGVybmFsIGV2ZW50IGhhbmRsaW5nXHJcblx0ZnVuY3Rpb24gZmlyZUV2ZW50ICggZXZlbnQsIGhhbmRsZU51bWJlciwgdGFwICkge1xyXG5cclxuXHRcdGlmICggaGFuZGxlTnVtYmVyICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5oYW5kbGVzICE9PSAxICkge1xyXG5cdFx0XHRoYW5kbGVOdW1iZXIgPSBNYXRoLmFicyhoYW5kbGVOdW1iZXIgLSBvcHRpb25zLmRpcik7XHJcblx0XHR9XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKCB0YXJnZXRFdmVudCApIHtcclxuXHJcblx0XHRcdHZhciBldmVudFR5cGUgPSB0YXJnZXRFdmVudC5zcGxpdCgnLicpWzBdO1xyXG5cclxuXHRcdFx0aWYgKCBldmVudCA9PT0gZXZlbnRUeXBlICkge1xyXG5cdFx0XHRcdHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiggY2FsbGJhY2sgKSB7XHJcblx0XHRcdFx0XHQvLyAucmV2ZXJzZSBpcyBpbiBwbGFjZVxyXG5cdFx0XHRcdFx0Ly8gUmV0dXJuIHZhbHVlcyBhcyBhcnJheSwgc28gYXJnXzFbYXJnXzJdIGlzIGFsd2F5cyB2YWxpZC5cclxuXHRcdFx0XHRcdGNhbGxiYWNrLmNhbGwoc2NvcGVfU2VsZiwgYXNBcnJheSh2YWx1ZUdldCgpKSwgaGFuZGxlTnVtYmVyLCBhc0FycmF5KGluU2xpZGVyT3JkZXIoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc2NvcGVfVmFsdWVzKSkpLCB0YXAgfHwgZmFsc2UpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIFJldHVybnMgdGhlIGlucHV0IGFycmF5LCByZXNwZWN0aW5nIHRoZSBzbGlkZXIgZGlyZWN0aW9uIGNvbmZpZ3VyYXRpb24uXHJcblx0ZnVuY3Rpb24gaW5TbGlkZXJPcmRlciAoIHZhbHVlcyApIHtcclxuXHJcblx0XHQvLyBJZiBvbmx5IG9uZSBoYW5kbGUgaXMgdXNlZCwgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxyXG5cdFx0aWYgKCB2YWx1ZXMubGVuZ3RoID09PSAxICl7XHJcblx0XHRcdHJldHVybiB2YWx1ZXNbMF07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvcHRpb25zLmRpciApIHtcclxuXHRcdFx0cmV0dXJuIHZhbHVlcy5yZXZlcnNlKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHZhbHVlcztcclxuXHR9XHJcblxyXG5cclxuXHQvLyBIYW5kbGVyIGZvciBhdHRhY2hpbmcgZXZlbnRzIHRyb3VnaCBhIHByb3h5LlxyXG5cdGZ1bmN0aW9uIGF0dGFjaCAoIGV2ZW50cywgZWxlbWVudCwgY2FsbGJhY2ssIGRhdGEgKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byAnZmlsdGVyJyBldmVudHMgdG8gdGhlIHNsaWRlci5cclxuXHRcdC8vIGVsZW1lbnQgaXMgYSBub2RlLCBub3QgYSBub2RlTGlzdFxyXG5cclxuXHRcdHZhciBtZXRob2QgPSBmdW5jdGlvbiAoIGUgKXtcclxuXHJcblx0XHRcdGlmICggc2NvcGVfVGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSApIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFN0b3AgaWYgYW4gYWN0aXZlICd0YXAnIHRyYW5zaXRpb24gaXMgdGFraW5nIHBsYWNlLlxyXG5cdFx0XHRpZiAoIGhhc0NsYXNzKHNjb3BlX1RhcmdldCwgY3NzQ2xhc3Nlc1sxNF0pICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZSA9IGZpeEV2ZW50KGUsIGRhdGEucGFnZU9mZnNldCk7XHJcblxyXG5cdFx0XHQvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XHJcblx0XHRcdGlmICggZXZlbnRzID09PSBhY3Rpb25zLnN0YXJ0ICYmIGUuYnV0dG9ucyAhPT0gdW5kZWZpbmVkICYmIGUuYnV0dG9ucyA+IDEgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJZ25vcmUgcmlnaHQgb3IgbWlkZGxlIGNsaWNrcyBvbiBzdGFydCAjNDU0XHJcblx0XHRcdGlmICggZGF0YS5ob3ZlciAmJiBlLmJ1dHRvbnMgKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRlLmNhbGNQb2ludCA9IGUucG9pbnRzWyBvcHRpb25zLm9ydCBdO1xyXG5cclxuXHRcdFx0Ly8gQ2FsbCB0aGUgZXZlbnQgaGFuZGxlciB3aXRoIHRoZSBldmVudCBbIGFuZCBhZGRpdGlvbmFsIGRhdGEgXS5cclxuXHRcdFx0Y2FsbGJhY2sgKCBlLCBkYXRhICk7XHJcblxyXG5cdFx0fSwgbWV0aG9kcyA9IFtdO1xyXG5cclxuXHRcdC8vIEJpbmQgYSBjbG9zdXJlIG9uIHRoZSB0YXJnZXQgZm9yIGV2ZXJ5IGV2ZW50IHR5cGUuXHJcblx0XHRldmVudHMuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKCBldmVudE5hbWUgKXtcclxuXHRcdFx0ZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgbWV0aG9kLCBmYWxzZSk7XHJcblx0XHRcdG1ldGhvZHMucHVzaChbZXZlbnROYW1lLCBtZXRob2RdKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHJldHVybiBtZXRob2RzO1xyXG5cdH1cclxuXHJcblx0Ly8gSGFuZGxlIG1vdmVtZW50IG9uIGRvY3VtZW50IGZvciBoYW5kbGUgYW5kIHJhbmdlIGRyYWcuXHJcblx0ZnVuY3Rpb24gbW92ZSAoIGV2ZW50LCBkYXRhICkge1xyXG5cclxuXHRcdC8vIEZpeCAjNDk4XHJcblx0XHQvLyBDaGVjayB2YWx1ZSBvZiAuYnV0dG9ucyBpbiAnc3RhcnQnIHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluIElFMTAgbW9iaWxlIChkYXRhLmJ1dHRvbnNQcm9wZXJ0eSkuXHJcblx0XHQvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzkyNzAwNS9tb2JpbGUtaWUxMC13aW5kb3dzLXBob25lLWJ1dHRvbnMtcHJvcGVydHktb2YtcG9pbnRlcm1vdmUtZXZlbnQtYWx3YXlzLXplcm9cclxuXHRcdC8vIElFOSBoYXMgLmJ1dHRvbnMgYW5kIC53aGljaCB6ZXJvIG9uIG1vdXNlbW92ZS5cclxuXHRcdC8vIEZpcmVmb3ggYnJlYWtzIHRoZSBzcGVjIE1ETiBkZWZpbmVzLlxyXG5cdFx0aWYgKCBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKFwiTVNJRSA5XCIpID09PSAtMSAmJiBldmVudC5idXR0b25zID09PSAwICYmIGRhdGEuYnV0dG9uc1Byb3BlcnR5ICE9PSAwICkge1xyXG5cdFx0XHRyZXR1cm4gZW5kKGV2ZW50LCBkYXRhKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaGFuZGxlcyA9IGRhdGEuaGFuZGxlcyB8fCBzY29wZV9IYW5kbGVzLCBwb3NpdGlvbnMsIHN0YXRlID0gZmFsc2UsXHJcblx0XHRcdHByb3Bvc2FsID0gKChldmVudC5jYWxjUG9pbnQgLSBkYXRhLnN0YXJ0KSAqIDEwMCkgLyBkYXRhLmJhc2VTaXplLFxyXG5cdFx0XHRoYW5kbGVOdW1iZXIgPSBoYW5kbGVzWzBdID09PSBzY29wZV9IYW5kbGVzWzBdID8gMCA6IDEsIGk7XHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHJlbGF0aXZlIHBvc2l0aW9ucyBmb3IgdGhlIGhhbmRsZXMuXHJcblx0XHRwb3NpdGlvbnMgPSBnZXRQb3NpdGlvbnMoIHByb3Bvc2FsLCBkYXRhLnBvc2l0aW9ucywgaGFuZGxlcy5sZW5ndGggPiAxKTtcclxuXHJcblx0XHRzdGF0ZSA9IHNldEhhbmRsZSAoIGhhbmRsZXNbMF0sIHBvc2l0aW9uc1toYW5kbGVOdW1iZXJdLCBoYW5kbGVzLmxlbmd0aCA9PT0gMSApO1xyXG5cclxuXHRcdGlmICggaGFuZGxlcy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0c3RhdGUgPSBzZXRIYW5kbGUgKCBoYW5kbGVzWzFdLCBwb3NpdGlvbnNbaGFuZGxlTnVtYmVyPzA6MV0sIGZhbHNlICkgfHwgc3RhdGU7XHJcblxyXG5cdFx0XHRpZiAoIHN0YXRlICkge1xyXG5cdFx0XHRcdC8vIGZpcmUgZm9yIGJvdGggaGFuZGxlc1xyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGF0YS5oYW5kbGVzLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRcdFx0ZmlyZUV2ZW50KCdzbGlkZScsIGkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICggc3RhdGUgKSB7XHJcblx0XHRcdC8vIEZpcmUgZm9yIGEgc2luZ2xlIGhhbmRsZVxyXG5cdFx0XHRmaXJlRXZlbnQoJ3NsaWRlJywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFVuYmluZCBtb3ZlIGV2ZW50cyBvbiBkb2N1bWVudCwgY2FsbCBjYWxsYmFja3MuXHJcblx0ZnVuY3Rpb24gZW5kICggZXZlbnQsIGRhdGEgKSB7XHJcblxyXG5cdFx0Ly8gVGhlIGhhbmRsZSBpcyBubyBsb25nZXIgYWN0aXZlLCBzbyByZW1vdmUgdGhlIGNsYXNzLlxyXG5cdFx0dmFyIGFjdGl2ZSA9IHNjb3BlX0Jhc2UucXVlcnlTZWxlY3RvciggJy4nICsgY3NzQ2xhc3Nlc1sxNV0gKSxcclxuXHRcdFx0aGFuZGxlTnVtYmVyID0gZGF0YS5oYW5kbGVzWzBdID09PSBzY29wZV9IYW5kbGVzWzBdID8gMCA6IDE7XHJcblxyXG5cdFx0aWYgKCBhY3RpdmUgIT09IG51bGwgKSB7XHJcblx0XHRcdHJlbW92ZUNsYXNzKGFjdGl2ZSwgY3NzQ2xhc3Nlc1sxNV0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFJlbW92ZSBjdXJzb3Igc3R5bGVzIGFuZCB0ZXh0LXNlbGVjdGlvbiBldmVudHMgYm91bmQgdG8gdGhlIGJvZHkuXHJcblx0XHRpZiAoIGV2ZW50LmN1cnNvciApIHtcclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSAnJztcclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIGRvY3VtZW50LmJvZHkubm9VaUxpc3RlbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcclxuXHJcblx0XHQvLyBVbmJpbmQgdGhlIG1vdmUgYW5kIGVuZCBldmVudHMsIHdoaWNoIGFyZSBhZGRlZCBvbiAnc3RhcnQnLlxyXG5cdFx0ZC5ub1VpTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oIGMgKSB7XHJcblx0XHRcdGQucmVtb3ZlRXZlbnRMaXN0ZW5lcihjWzBdLCBjWzFdKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdC8vIFJlbW92ZSBkcmFnZ2luZyBjbGFzcy5cclxuXHRcdHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgY3NzQ2xhc3Nlc1sxMl0pO1xyXG5cclxuXHRcdC8vIEZpcmUgdGhlIGNoYW5nZSBhbmQgc2V0IGV2ZW50cy5cclxuXHRcdGZpcmVFdmVudCgnc2V0JywgaGFuZGxlTnVtYmVyKTtcclxuXHRcdGZpcmVFdmVudCgnY2hhbmdlJywgaGFuZGxlTnVtYmVyKTtcclxuXHJcblx0XHQvLyBJZiB0aGlzIGlzIGEgc3RhbmRhcmQgaGFuZGxlIG1vdmVtZW50LCBmaXJlIHRoZSBlbmQgZXZlbnQuXHJcblx0XHRpZiAoIGRhdGEuaGFuZGxlTnVtYmVyICE9PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdGZpcmVFdmVudCgnZW5kJywgZGF0YS5oYW5kbGVOdW1iZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gRmlyZSAnZW5kJyB3aGVuIGEgbW91c2Ugb3IgcGVuIGxlYXZlcyB0aGUgZG9jdW1lbnQuXHJcblx0ZnVuY3Rpb24gZG9jdW1lbnRMZWF2ZSAoIGV2ZW50LCBkYXRhICkge1xyXG5cdFx0aWYgKCBldmVudC50eXBlID09PSBcIm1vdXNlb3V0XCIgJiYgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkhUTUxcIiAmJiBldmVudC5yZWxhdGVkVGFyZ2V0ID09PSBudWxsICl7XHJcblx0XHRcdGVuZCAoIGV2ZW50LCBkYXRhICk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBCaW5kIG1vdmUgZXZlbnRzIG9uIGRvY3VtZW50LlxyXG5cdGZ1bmN0aW9uIHN0YXJ0ICggZXZlbnQsIGRhdGEgKSB7XHJcblxyXG5cdFx0dmFyIGQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XHJcblxyXG5cdFx0Ly8gTWFyayB0aGUgaGFuZGxlIGFzICdhY3RpdmUnIHNvIGl0IGNhbiBiZSBzdHlsZWQuXHJcblx0XHRpZiAoIGRhdGEuaGFuZGxlcy5sZW5ndGggPT09IDEgKSB7XHJcblx0XHRcdGFkZENsYXNzKGRhdGEuaGFuZGxlc1swXS5jaGlsZHJlblswXSwgY3NzQ2xhc3Nlc1sxNV0pO1xyXG5cclxuXHRcdFx0Ly8gU3VwcG9ydCAnZGlzYWJsZWQnIGhhbmRsZXNcclxuXHRcdFx0aWYgKCBkYXRhLmhhbmRsZXNbMF0uaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpICkge1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpeCAjNTUxLCB3aGVyZSBhIGhhbmRsZSBnZXRzIHNlbGVjdGVkIGluc3RlYWQgb2YgZHJhZ2dlZC5cclxuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cdFx0Ly8gQSBkcmFnIHNob3VsZCBuZXZlciBwcm9wYWdhdGUgdXAgdG8gdGhlICd0YXAnIGV2ZW50LlxyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0Ly8gQXR0YWNoIHRoZSBtb3ZlIGFuZCBlbmQgZXZlbnRzLlxyXG5cdFx0dmFyIG1vdmVFdmVudCA9IGF0dGFjaChhY3Rpb25zLm1vdmUsIGQsIG1vdmUsIHtcclxuXHRcdFx0c3RhcnQ6IGV2ZW50LmNhbGNQb2ludCxcclxuXHRcdFx0YmFzZVNpemU6IGJhc2VTaXplKCksXHJcblx0XHRcdHBhZ2VPZmZzZXQ6IGV2ZW50LnBhZ2VPZmZzZXQsXHJcblx0XHRcdGhhbmRsZXM6IGRhdGEuaGFuZGxlcyxcclxuXHRcdFx0aGFuZGxlTnVtYmVyOiBkYXRhLmhhbmRsZU51bWJlcixcclxuXHRcdFx0YnV0dG9uc1Byb3BlcnR5OiBldmVudC5idXR0b25zLFxyXG5cdFx0XHRwb3NpdGlvbnM6IFtcclxuXHRcdFx0XHRzY29wZV9Mb2NhdGlvbnNbMF0sXHJcblx0XHRcdFx0c2NvcGVfTG9jYXRpb25zW3Njb3BlX0hhbmRsZXMubGVuZ3RoIC0gMV1cclxuXHRcdFx0XVxyXG5cdFx0fSksIGVuZEV2ZW50ID0gYXR0YWNoKGFjdGlvbnMuZW5kLCBkLCBlbmQsIHtcclxuXHRcdFx0aGFuZGxlczogZGF0YS5oYW5kbGVzLFxyXG5cdFx0XHRoYW5kbGVOdW1iZXI6IGRhdGEuaGFuZGxlTnVtYmVyXHJcblx0XHR9KTtcclxuXHJcblx0XHR2YXIgb3V0RXZlbnQgPSBhdHRhY2goXCJtb3VzZW91dFwiLCBkLCBkb2N1bWVudExlYXZlLCB7XHJcblx0XHRcdGhhbmRsZXM6IGRhdGEuaGFuZGxlcyxcclxuXHRcdFx0aGFuZGxlTnVtYmVyOiBkYXRhLmhhbmRsZU51bWJlclxyXG5cdFx0fSk7XHJcblxyXG5cdFx0ZC5ub1VpTGlzdGVuZXJzID0gbW92ZUV2ZW50LmNvbmNhdChlbmRFdmVudCwgb3V0RXZlbnQpO1xyXG5cclxuXHRcdC8vIFRleHQgc2VsZWN0aW9uIGlzbid0IGFuIGlzc3VlIG9uIHRvdWNoIGRldmljZXMsXHJcblx0XHQvLyBzbyBhZGRpbmcgY3Vyc29yIHN0eWxlcyBjYW4gYmUgc2tpcHBlZC5cclxuXHRcdGlmICggZXZlbnQuY3Vyc29yICkge1xyXG5cclxuXHRcdFx0Ly8gUHJldmVudCB0aGUgJ0knIGN1cnNvciBhbmQgZXh0ZW5kIHRoZSByYW5nZS1kcmFnIGN1cnNvci5cclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5zdHlsZS5jdXJzb3IgPSBnZXRDb21wdXRlZFN0eWxlKGV2ZW50LnRhcmdldCkuY3Vyc29yO1xyXG5cclxuXHRcdFx0Ly8gTWFyayB0aGUgdGFyZ2V0IHdpdGggYSBkcmFnZ2luZyBzdGF0ZS5cclxuXHRcdFx0aWYgKCBzY29wZV9IYW5kbGVzLmxlbmd0aCA+IDEgKSB7XHJcblx0XHRcdFx0YWRkQ2xhc3Moc2NvcGVfVGFyZ2V0LCBjc3NDbGFzc2VzWzEyXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBmID0gZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRkb2N1bWVudC5ib2R5Lm5vVWlMaXN0ZW5lciA9IGY7XHJcblxyXG5cdFx0XHQvLyBQcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoZW4gZHJhZ2dpbmcgdGhlIGhhbmRsZXMuXHJcblx0XHRcdGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0c3RhcnQnLCBmLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkYXRhLmhhbmRsZU51bWJlciAhPT0gdW5kZWZpbmVkICkge1xyXG5cdFx0XHRmaXJlRXZlbnQoJ3N0YXJ0JywgZGF0YS5oYW5kbGVOdW1iZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gTW92ZSBjbG9zZXN0IGhhbmRsZSB0byB0YXBwZWQgbG9jYXRpb24uXHJcblx0ZnVuY3Rpb24gdGFwICggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGxvY2F0aW9uID0gZXZlbnQuY2FsY1BvaW50LCB0b3RhbCA9IDAsIGhhbmRsZU51bWJlciwgdG87XHJcblxyXG5cdFx0Ly8gVGhlIHRhcCBldmVudCBzaG91bGRuJ3QgcHJvcGFnYXRlIHVwIGFuZCBjYXVzZSAnZWRnZScgdG8gcnVuLlxyXG5cdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG5cdFx0Ly8gQWRkIHVwIHRoZSBoYW5kbGUgb2Zmc2V0cy5cclxuXHRcdHNjb3BlX0hhbmRsZXMuZm9yRWFjaChmdW5jdGlvbihhKXtcclxuXHRcdFx0dG90YWwgKz0gb2Zmc2V0KGEpWyBvcHRpb25zLnN0eWxlIF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBGaW5kIHRoZSBoYW5kbGUgY2xvc2VzdCB0byB0aGUgdGFwcGVkIHBvc2l0aW9uLlxyXG5cdFx0aGFuZGxlTnVtYmVyID0gKCBsb2NhdGlvbiA8IHRvdGFsLzIgfHwgc2NvcGVfSGFuZGxlcy5sZW5ndGggPT09IDEgKSA/IDAgOiAxO1xyXG5cclxuXHRcdGxvY2F0aW9uIC09IG9mZnNldChzY29wZV9CYXNlKVsgb3B0aW9ucy5zdHlsZSBdO1xyXG5cclxuXHRcdC8vIENhbGN1bGF0ZSB0aGUgbmV3IHBvc2l0aW9uLlxyXG5cdFx0dG8gPSAoIGxvY2F0aW9uICogMTAwICkgLyBiYXNlU2l6ZSgpO1xyXG5cclxuXHRcdGlmICggIW9wdGlvbnMuZXZlbnRzLnNuYXAgKSB7XHJcblx0XHRcdC8vIEZsYWcgdGhlIHNsaWRlciBhcyBpdCBpcyBub3cgaW4gYSB0cmFuc2l0aW9uYWwgc3RhdGUuXHJcblx0XHRcdC8vIFRyYW5zaXRpb24gdGFrZXMgMzAwIG1zLCBzbyByZS1lbmFibGUgdGhlIHNsaWRlciBhZnRlcndhcmRzLlxyXG5cdFx0XHRhZGRDbGFzc0Zvciggc2NvcGVfVGFyZ2V0LCBjc3NDbGFzc2VzWzE0XSwgMzAwICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU3VwcG9ydCAnZGlzYWJsZWQnIGhhbmRsZXNcclxuXHRcdGlmICggc2NvcGVfSGFuZGxlc1toYW5kbGVOdW1iZXJdLmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSApIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpbmQgdGhlIGNsb3Nlc3QgaGFuZGxlIGFuZCBjYWxjdWxhdGUgdGhlIHRhcHBlZCBwb2ludC5cclxuXHRcdC8vIFRoZSBzZXQgaGFuZGxlIHRvIHRoZSBuZXcgcG9zaXRpb24uXHJcblx0XHRzZXRIYW5kbGUoIHNjb3BlX0hhbmRsZXNbaGFuZGxlTnVtYmVyXSwgdG8gKTtcclxuXHJcblx0XHRmaXJlRXZlbnQoJ3NsaWRlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgnc2V0JywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHRcdGZpcmVFdmVudCgnY2hhbmdlJywgaGFuZGxlTnVtYmVyLCB0cnVlKTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMuZXZlbnRzLnNuYXAgKSB7XHJcblx0XHRcdHN0YXJ0KGV2ZW50LCB7IGhhbmRsZXM6IFtzY29wZV9IYW5kbGVzW2hhbmRsZU51bWJlcl1dIH0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gRmlyZXMgYSAnaG92ZXInIGV2ZW50IGZvciBhIGhvdmVyZWQgbW91c2UvcGVuIHBvc2l0aW9uLlxyXG5cdGZ1bmN0aW9uIGhvdmVyICggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGxvY2F0aW9uID0gZXZlbnQuY2FsY1BvaW50IC0gb2Zmc2V0KHNjb3BlX0Jhc2UpWyBvcHRpb25zLnN0eWxlIF0sXHJcblx0XHRcdHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCgoIGxvY2F0aW9uICogMTAwICkgLyBiYXNlU2l6ZSgpKSxcclxuXHRcdFx0dmFsdWUgPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoIHRvICk7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKCB0YXJnZXRFdmVudCApIHtcclxuXHRcdFx0aWYgKCAnaG92ZXInID09PSB0YXJnZXRFdmVudC5zcGxpdCgnLicpWzBdICkge1xyXG5cdFx0XHRcdHNjb3BlX0V2ZW50c1t0YXJnZXRFdmVudF0uZm9yRWFjaChmdW5jdGlvbiggY2FsbGJhY2sgKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKCBzY29wZV9TZWxmLCB2YWx1ZSApO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9XHJcblxyXG5cdC8vIEF0dGFjaCBldmVudHMgdG8gc2V2ZXJhbCBzbGlkZXIgcGFydHMuXHJcblx0ZnVuY3Rpb24gZXZlbnRzICggYmVoYXZpb3VyICkge1xyXG5cclxuXHRcdHZhciBpLCBkcmFnO1xyXG5cclxuXHRcdC8vIEF0dGFjaCB0aGUgc3RhbmRhcmQgZHJhZyBldmVudCB0byB0aGUgaGFuZGxlcy5cclxuXHRcdGlmICggIWJlaGF2aW91ci5maXhlZCApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGg7IGkgKz0gMSApIHtcclxuXHJcblx0XHRcdFx0Ly8gVGhlc2UgZXZlbnRzIGFyZSBvbmx5IGJvdW5kIHRvIHRoZSB2aXN1YWwgaGFuZGxlXHJcblx0XHRcdFx0Ly8gZWxlbWVudCwgbm90IHRoZSAncmVhbCcgb3JpZ2luIGVsZW1lbnQuXHJcblx0XHRcdFx0YXR0YWNoICggYWN0aW9ucy5zdGFydCwgc2NvcGVfSGFuZGxlc1tpXS5jaGlsZHJlblswXSwgc3RhcnQsIHtcclxuXHRcdFx0XHRcdGhhbmRsZXM6IFsgc2NvcGVfSGFuZGxlc1tpXSBdLFxyXG5cdFx0XHRcdFx0aGFuZGxlTnVtYmVyOiBpXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHQvLyBBdHRhY2ggdGhlIHRhcCBldmVudCB0byB0aGUgc2xpZGVyIGJhc2UuXHJcblx0XHRpZiAoIGJlaGF2aW91ci50YXAgKSB7XHJcblxyXG5cdFx0XHRhdHRhY2ggKCBhY3Rpb25zLnN0YXJ0LCBzY29wZV9CYXNlLCB0YXAsIHtcclxuXHRcdFx0XHRoYW5kbGVzOiBzY29wZV9IYW5kbGVzXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEZpcmUgaG92ZXIgZXZlbnRzXHJcblx0XHRpZiAoIGJlaGF2aW91ci5ob3ZlciApIHtcclxuXHRcdFx0YXR0YWNoICggYWN0aW9ucy5tb3ZlLCBzY29wZV9CYXNlLCBob3ZlciwgeyBob3ZlcjogdHJ1ZSB9ICk7XHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgc2NvcGVfSGFuZGxlcy5sZW5ndGg7IGkgKz0gMSApIHtcclxuXHRcdFx0XHRbJ21vdXNlbW92ZSBNU1BvaW50ZXJNb3ZlIHBvaW50ZXJtb3ZlJ10uZm9yRWFjaChmdW5jdGlvbiggZXZlbnROYW1lICl7XHJcblx0XHRcdFx0XHRzY29wZV9IYW5kbGVzW2ldLmNoaWxkcmVuWzBdLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBzdG9wUHJvcGFnYXRpb24sIGZhbHNlKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE1ha2UgdGhlIHJhbmdlIGRyYWdnYWJsZS5cclxuXHRcdGlmICggYmVoYXZpb3VyLmRyYWcgKXtcclxuXHJcblx0XHRcdGRyYWcgPSBbc2NvcGVfQmFzZS5xdWVyeVNlbGVjdG9yKCAnLicgKyBjc3NDbGFzc2VzWzddICldO1xyXG5cdFx0XHRhZGRDbGFzcyhkcmFnWzBdLCBjc3NDbGFzc2VzWzEwXSk7XHJcblxyXG5cdFx0XHQvLyBXaGVuIHRoZSByYW5nZSBpcyBmaXhlZCwgdGhlIGVudGlyZSByYW5nZSBjYW5cclxuXHRcdFx0Ly8gYmUgZHJhZ2dlZCBieSB0aGUgaGFuZGxlcy4gVGhlIGhhbmRsZSBpbiB0aGUgZmlyc3RcclxuXHRcdFx0Ly8gb3JpZ2luIHdpbGwgcHJvcGFnYXRlIHRoZSBzdGFydCBldmVudCB1cHdhcmQsXHJcblx0XHRcdC8vIGJ1dCBpdCBuZWVkcyB0byBiZSBib3VuZCBtYW51YWxseSBvbiB0aGUgb3RoZXIuXHJcblx0XHRcdGlmICggYmVoYXZpb3VyLmZpeGVkICkge1xyXG5cdFx0XHRcdGRyYWcucHVzaChzY29wZV9IYW5kbGVzWyhkcmFnWzBdID09PSBzY29wZV9IYW5kbGVzWzBdID8gMSA6IDApXS5jaGlsZHJlblswXSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRyYWcuZm9yRWFjaChmdW5jdGlvbiggZWxlbWVudCApIHtcclxuXHRcdFx0XHRhdHRhY2ggKCBhY3Rpb25zLnN0YXJ0LCBlbGVtZW50LCBzdGFydCwge1xyXG5cdFx0XHRcdFx0aGFuZGxlczogc2NvcGVfSGFuZGxlc1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBUZXN0IHN1Z2dlc3RlZCB2YWx1ZXMgYW5kIGFwcGx5IG1hcmdpbiwgc3RlcC5cclxuXHRmdW5jdGlvbiBzZXRIYW5kbGUgKCBoYW5kbGUsIHRvLCBub0xpbWl0T3B0aW9uICkge1xyXG5cclxuXHRcdHZhciB0cmlnZ2VyID0gaGFuZGxlICE9PSBzY29wZV9IYW5kbGVzWzBdID8gMSA6IDAsXHJcblx0XHRcdGxvd2VyTWFyZ2luID0gc2NvcGVfTG9jYXRpb25zWzBdICsgb3B0aW9ucy5tYXJnaW4sXHJcblx0XHRcdHVwcGVyTWFyZ2luID0gc2NvcGVfTG9jYXRpb25zWzFdIC0gb3B0aW9ucy5tYXJnaW4sXHJcblx0XHRcdGxvd2VyTGltaXQgPSBzY29wZV9Mb2NhdGlvbnNbMF0gKyBvcHRpb25zLmxpbWl0LFxyXG5cdFx0XHR1cHBlckxpbWl0ID0gc2NvcGVfTG9jYXRpb25zWzFdIC0gb3B0aW9ucy5saW1pdDtcclxuXHJcblx0XHQvLyBGb3Igc2xpZGVycyB3aXRoIG11bHRpcGxlIGhhbmRsZXMsXHJcblx0XHQvLyBsaW1pdCBtb3ZlbWVudCB0byB0aGUgb3RoZXIgaGFuZGxlLlxyXG5cdFx0Ly8gQXBwbHkgdGhlIG1hcmdpbiBvcHRpb24gYnkgYWRkaW5nIGl0IHRvIHRoZSBoYW5kbGUgcG9zaXRpb25zLlxyXG5cdFx0aWYgKCBzY29wZV9IYW5kbGVzLmxlbmd0aCA+IDEgKSB7XHJcblx0XHRcdHRvID0gdHJpZ2dlciA/IE1hdGgubWF4KCB0bywgbG93ZXJNYXJnaW4gKSA6IE1hdGgubWluKCB0bywgdXBwZXJNYXJnaW4gKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUaGUgbGltaXQgb3B0aW9uIGhhcyB0aGUgb3Bwb3NpdGUgZWZmZWN0LCBsaW1pdGluZyBoYW5kbGVzIHRvIGFcclxuXHRcdC8vIG1heGltdW0gZGlzdGFuY2UgZnJvbSBhbm90aGVyLiBMaW1pdCBtdXN0IGJlID4gMCwgYXMgb3RoZXJ3aXNlXHJcblx0XHQvLyBoYW5kbGVzIHdvdWxkIGJlIHVubW92ZWFibGUuICdub0xpbWl0T3B0aW9uJyBpcyBzZXQgdG8gJ2ZhbHNlJ1xyXG5cdFx0Ly8gZm9yIHRoZSAudmFsKCkgbWV0aG9kLCBleGNlcHQgZm9yIHBhc3MgNC80LlxyXG5cdFx0aWYgKCBub0xpbWl0T3B0aW9uICE9PSBmYWxzZSAmJiBvcHRpb25zLmxpbWl0ICYmIHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSApIHtcclxuXHRcdFx0dG8gPSB0cmlnZ2VyID8gTWF0aC5taW4gKCB0bywgbG93ZXJMaW1pdCApIDogTWF0aC5tYXgoIHRvLCB1cHBlckxpbWl0ICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGFuZGxlIHRoZSBzdGVwIG9wdGlvbi5cclxuXHRcdHRvID0gc2NvcGVfU3BlY3RydW0uZ2V0U3RlcCggdG8gKTtcclxuXHJcblx0XHQvLyBMaW1pdCB0byAwLzEwMCBmb3IgLnZhbCBpbnB1dCwgdHJpbSBhbnl0aGluZyBiZXlvbmQgNyBkaWdpdHMsIGFzXHJcblx0XHQvLyBKYXZhU2NyaXB0IGhhcyBzb21lIGlzc3VlcyBpbiBpdHMgZmxvYXRpbmcgcG9pbnQgaW1wbGVtZW50YXRpb24uXHJcblx0XHR0byA9IGxpbWl0KHBhcnNlRmxvYXQodG8udG9GaXhlZCg3KSkpO1xyXG5cclxuXHRcdC8vIFJldHVybiBmYWxzZSBpZiBoYW5kbGUgY2FuJ3QgbW92ZVxyXG5cdFx0aWYgKCB0byA9PT0gc2NvcGVfTG9jYXRpb25zW3RyaWdnZXJdICkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gU2V0IHRoZSBoYW5kbGUgdG8gdGhlIG5ldyBwb3NpdGlvbi5cclxuXHRcdC8vIFVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZm9yIGVmZmljaWVudCBwYWludGluZy5cclxuXHRcdC8vIE5vIHNpZ25pZmljYW50IGVmZmVjdCBpbiBDaHJvbWUsIEVkZ2Ugc2VlcyBkcmFtYXRpY1xyXG5cdFx0Ly8gcGVyZm9ybWFjZSBpbXByb3ZlbWVudHMuXHJcblx0XHRpZiAoIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XHJcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcclxuXHRcdFx0XHRoYW5kbGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSB0byArICclJztcclxuXHRcdFx0fSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoYW5kbGUuc3R5bGVbb3B0aW9ucy5zdHlsZV0gPSB0byArICclJztcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGb3JjZSBwcm9wZXIgaGFuZGxlIHN0YWNraW5nXHJcblx0XHRpZiAoICFoYW5kbGUucHJldmlvdXNTaWJsaW5nICkge1xyXG5cdFx0XHRyZW1vdmVDbGFzcyhoYW5kbGUsIGNzc0NsYXNzZXNbMTddKTtcclxuXHRcdFx0aWYgKCB0byA+IDUwICkge1xyXG5cdFx0XHRcdGFkZENsYXNzKGhhbmRsZSwgY3NzQ2xhc3Nlc1sxN10pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gVXBkYXRlIGxvY2F0aW9ucy5cclxuXHRcdHNjb3BlX0xvY2F0aW9uc1t0cmlnZ2VyXSA9IHRvO1xyXG5cclxuXHRcdC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIHRoZSBzbGlkZXIgc3RlcHBpbmcvcmFuZ2UuXHJcblx0XHRzY29wZV9WYWx1ZXNbdHJpZ2dlcl0gPSBzY29wZV9TcGVjdHJ1bS5mcm9tU3RlcHBpbmcoIHRvICk7XHJcblxyXG5cdFx0ZmlyZUV2ZW50KCd1cGRhdGUnLCB0cmlnZ2VyKTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblxyXG5cdC8vIExvb3AgdmFsdWVzIGZyb20gdmFsdWUgbWV0aG9kIGFuZCBhcHBseSB0aGVtLlxyXG5cdGZ1bmN0aW9uIHNldFZhbHVlcyAoIGNvdW50LCB2YWx1ZXMgKSB7XHJcblxyXG5cdFx0dmFyIGksIHRyaWdnZXIsIHRvO1xyXG5cclxuXHRcdC8vIFdpdGggdGhlIGxpbWl0IG9wdGlvbiwgd2UnbGwgbmVlZCBhbm90aGVyIGxpbWl0aW5nIHBhc3MuXHJcblx0XHRpZiAoIG9wdGlvbnMubGltaXQgKSB7XHJcblx0XHRcdGNvdW50ICs9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGhhbmRsZXMgdG8gYmUgc2V0IHJ1biB0aGUgc2V0dGluZ1xyXG5cdFx0Ly8gbWVjaGFuaXNtIHR3aWNlIGZvciB0aGUgZmlyc3QgaGFuZGxlLCB0byBtYWtlIHN1cmUgaXRcclxuXHRcdC8vIGNhbiBiZSBib3VuY2VkIG9mIHRoZSBzZWNvbmQgb25lIHByb3Blcmx5LlxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxICkge1xyXG5cclxuXHRcdFx0dHJpZ2dlciA9IGklMjtcclxuXHJcblx0XHRcdC8vIEdldCB0aGUgY3VycmVudCBhcmd1bWVudCBmcm9tIHRoZSBhcnJheS5cclxuXHRcdFx0dG8gPSB2YWx1ZXNbdHJpZ2dlcl07XHJcblxyXG5cdFx0XHQvLyBTZXR0aW5nIHdpdGggbnVsbCBpbmRpY2F0ZXMgYW4gJ2lnbm9yZScuXHJcblx0XHRcdC8vIElucHV0dGluZyAnZmFsc2UnIGlzIGludmFsaWQuXHJcblx0XHRcdGlmICggdG8gIT09IG51bGwgJiYgdG8gIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHQvLyBJZiBhIGZvcm1hdHRlZCBudW1iZXIgd2FzIHBhc3NlZCwgYXR0ZW10IHRvIGRlY29kZSBpdC5cclxuXHRcdFx0XHRpZiAoIHR5cGVvZiB0byA9PT0gJ251bWJlcicgKSB7XHJcblx0XHRcdFx0XHR0byA9IFN0cmluZyh0byk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0byA9IG9wdGlvbnMuZm9ybWF0LmZyb20oIHRvICk7XHJcblxyXG5cdFx0XHRcdC8vIFJlcXVlc3QgYW4gdXBkYXRlIGZvciBhbGwgbGlua3MgaWYgdGhlIHZhbHVlIHdhcyBpbnZhbGlkLlxyXG5cdFx0XHRcdC8vIERvIHNvIHRvbyBpZiBzZXR0aW5nIHRoZSBoYW5kbGUgZmFpbHMuXHJcblx0XHRcdFx0aWYgKCB0byA9PT0gZmFsc2UgfHwgaXNOYU4odG8pIHx8IHNldEhhbmRsZSggc2NvcGVfSGFuZGxlc1t0cmlnZ2VyXSwgc2NvcGVfU3BlY3RydW0udG9TdGVwcGluZyggdG8gKSwgaSA9PT0gKDMgLSBvcHRpb25zLmRpcikgKSA9PT0gZmFsc2UgKSB7XHJcblx0XHRcdFx0XHRmaXJlRXZlbnQoJ3VwZGF0ZScsIHRyaWdnZXIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gU2V0IHRoZSBzbGlkZXIgdmFsdWUuXHJcblx0ZnVuY3Rpb24gdmFsdWVTZXQgKCBpbnB1dCApIHtcclxuXHJcblx0XHR2YXIgY291bnQsIHZhbHVlcyA9IGFzQXJyYXkoIGlucHV0ICksIGk7XHJcblxyXG5cdFx0Ly8gVGhlIFJUTCBzZXR0aW5ncyBpcyBpbXBsZW1lbnRlZCBieSByZXZlcnNpbmcgdGhlIGZyb250LWVuZCxcclxuXHRcdC8vIGludGVybmFsIG1lY2hhbmlzbXMgYXJlIHRoZSBzYW1lLlxyXG5cdFx0aWYgKCBvcHRpb25zLmRpciAmJiBvcHRpb25zLmhhbmRsZXMgPiAxICkge1xyXG5cdFx0XHR2YWx1ZXMucmV2ZXJzZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEFuaW1hdGlvbiBpcyBvcHRpb25hbC5cclxuXHRcdC8vIE1ha2Ugc3VyZSB0aGUgaW5pdGlhbCB2YWx1ZXMgd2hlcmUgc2V0IGJlZm9yZSB1c2luZyBhbmltYXRlZCBwbGFjZW1lbnQuXHJcblx0XHRpZiAoIG9wdGlvbnMuYW5pbWF0ZSAmJiBzY29wZV9Mb2NhdGlvbnNbMF0gIT09IC0xICkge1xyXG5cdFx0XHRhZGRDbGFzc0Zvciggc2NvcGVfVGFyZ2V0LCBjc3NDbGFzc2VzWzE0XSwgMzAwICk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRGV0ZXJtaW5lIGhvdyBvZnRlbiB0byBzZXQgdGhlIGhhbmRsZXMuXHJcblx0XHRjb3VudCA9IHNjb3BlX0hhbmRsZXMubGVuZ3RoID4gMSA/IDMgOiAxO1xyXG5cclxuXHRcdGlmICggdmFsdWVzLmxlbmd0aCA9PT0gMSApIHtcclxuXHRcdFx0Y291bnQgPSAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdHNldFZhbHVlcyAoIGNvdW50LCB2YWx1ZXMgKTtcclxuXHJcblx0XHQvLyBGaXJlIHRoZSAnc2V0JyBldmVudCBmb3IgYm90aCBoYW5kbGVzLlxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBzY29wZV9IYW5kbGVzLmxlbmd0aDsgaSsrICkge1xyXG5cdFx0XHRmaXJlRXZlbnQoJ3NldCcsIGkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gR2V0IHRoZSBzbGlkZXIgdmFsdWUuXHJcblx0ZnVuY3Rpb24gdmFsdWVHZXQgKCApIHtcclxuXHJcblx0XHR2YXIgaSwgcmV0b3VyID0gW107XHJcblxyXG5cdFx0Ly8gR2V0IHRoZSB2YWx1ZSBmcm9tIGFsbCBoYW5kbGVzLlxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBvcHRpb25zLmhhbmRsZXM7IGkgKz0gMSApe1xyXG5cdFx0XHRyZXRvdXJbaV0gPSBvcHRpb25zLmZvcm1hdC50byggc2NvcGVfVmFsdWVzW2ldICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGluU2xpZGVyT3JkZXIoIHJldG91ciApO1xyXG5cdH1cclxuXHJcblx0Ly8gUmVtb3ZlcyBjbGFzc2VzIGZyb20gdGhlIHJvb3QgYW5kIGVtcHRpZXMgaXQuXHJcblx0ZnVuY3Rpb24gZGVzdHJveSAoICkge1xyXG5cdFx0Y3NzQ2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uKGNscyl7XHJcblx0XHRcdGlmICggIWNscyApIHsgcmV0dXJuOyB9IC8vIElnbm9yZSBlbXB0eSBjbGFzc2VzXHJcblx0XHRcdHJlbW92ZUNsYXNzKHNjb3BlX1RhcmdldCwgY2xzKTtcclxuXHRcdH0pO1xyXG5cdFx0c2NvcGVfVGFyZ2V0LmlubmVySFRNTCA9ICcnO1xyXG5cdFx0ZGVsZXRlIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyO1xyXG5cdH1cclxuXHJcblx0Ly8gR2V0IHRoZSBjdXJyZW50IHN0ZXAgc2l6ZSBmb3IgdGhlIHNsaWRlci5cclxuXHRmdW5jdGlvbiBnZXRDdXJyZW50U3RlcCAoICkge1xyXG5cclxuXHRcdC8vIENoZWNrIGFsbCBsb2NhdGlvbnMsIG1hcCB0aGVtIHRvIHRoZWlyIHN0ZXBwaW5nIHBvaW50LlxyXG5cdFx0Ly8gR2V0IHRoZSBzdGVwIHBvaW50LCB0aGVuIGZpbmQgaXQgaW4gdGhlIGlucHV0IGxpc3QuXHJcblx0XHR2YXIgcmV0b3VyID0gc2NvcGVfTG9jYXRpb25zLm1hcChmdW5jdGlvbiggbG9jYXRpb24sIGluZGV4ICl7XHJcblxyXG5cdFx0XHR2YXIgc3RlcCA9IHNjb3BlX1NwZWN0cnVtLmdldEFwcGxpY2FibGVTdGVwKCBsb2NhdGlvbiApLFxyXG5cclxuXHRcdFx0XHQvLyBBcyBwZXIgIzM5MSwgdGhlIGNvbXBhcmlzb24gZm9yIHRoZSBkZWNyZW1lbnQgc3RlcCBjYW4gaGF2ZSBzb21lIHJvdW5kaW5nIGlzc3Vlcy5cclxuXHRcdFx0XHQvLyBSb3VuZCB0aGUgdmFsdWUgdG8gdGhlIHByZWNpc2lvbiB1c2VkIGluIHRoZSBzdGVwLlxyXG5cdFx0XHRcdHN0ZXBEZWNpbWFscyA9IGNvdW50RGVjaW1hbHMoU3RyaW5nKHN0ZXBbMl0pKSxcclxuXHJcblx0XHRcdFx0Ly8gR2V0IHRoZSBjdXJyZW50IG51bWVyaWMgdmFsdWVcclxuXHRcdFx0XHR2YWx1ZSA9IHNjb3BlX1ZhbHVlc1tpbmRleF0sXHJcblxyXG5cdFx0XHRcdC8vIFRvIG1vdmUgdGhlIHNsaWRlciAnb25lIHN0ZXAgdXAnLCB0aGUgY3VycmVudCBzdGVwIHZhbHVlIG5lZWRzIHRvIGJlIGFkZGVkLlxyXG5cdFx0XHRcdC8vIFVzZSBudWxsIGlmIHdlIGFyZSBhdCB0aGUgbWF4aW11bSBzbGlkZXIgdmFsdWUuXHJcblx0XHRcdFx0aW5jcmVtZW50ID0gbG9jYXRpb24gPT09IDEwMCA/IG51bGwgOiBzdGVwWzJdLFxyXG5cclxuXHRcdFx0XHQvLyBHb2luZyAnb25lIHN0ZXAgZG93bicgbWlnaHQgcHV0IHRoZSBzbGlkZXIgaW4gYSBkaWZmZXJlbnQgc3ViLXJhbmdlLCBzbyB3ZVxyXG5cdFx0XHRcdC8vIG5lZWQgdG8gc3dpdGNoIGJldHdlZW4gdGhlIGN1cnJlbnQgb3IgdGhlIHByZXZpb3VzIHN0ZXAuXHJcblx0XHRcdFx0cHJldiA9IE51bWJlcigodmFsdWUgLSBzdGVwWzJdKS50b0ZpeGVkKHN0ZXBEZWNpbWFscykpLFxyXG5cclxuXHRcdFx0XHQvLyBJZiB0aGUgdmFsdWUgZml0cyB0aGUgc3RlcCwgcmV0dXJuIHRoZSBjdXJyZW50IHN0ZXAgdmFsdWUuIE90aGVyd2lzZSwgdXNlIHRoZVxyXG5cdFx0XHRcdC8vIHByZXZpb3VzIHN0ZXAuIFJldHVybiBudWxsIGlmIHRoZSBzbGlkZXIgaXMgYXQgaXRzIG1pbmltdW0gdmFsdWUuXHJcblx0XHRcdFx0ZGVjcmVtZW50ID0gbG9jYXRpb24gPT09IDAgPyBudWxsIDogKHByZXYgPj0gc3RlcFsxXSkgPyBzdGVwWzJdIDogKHN0ZXBbMF0gfHwgZmFsc2UpO1xyXG5cclxuXHRcdFx0cmV0dXJuIFtkZWNyZW1lbnQsIGluY3JlbWVudF07XHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBSZXR1cm4gdmFsdWVzIGluIHRoZSBwcm9wZXIgb3JkZXIuXHJcblx0XHRyZXR1cm4gaW5TbGlkZXJPcmRlciggcmV0b3VyICk7XHJcblx0fVxyXG5cclxuXHQvLyBBdHRhY2ggYW4gZXZlbnQgdG8gdGhpcyBzbGlkZXIsIHBvc3NpYmx5IGluY2x1ZGluZyBhIG5hbWVzcGFjZVxyXG5cdGZ1bmN0aW9uIGJpbmRFdmVudCAoIG5hbWVzcGFjZWRFdmVudCwgY2FsbGJhY2sgKSB7XHJcblx0XHRzY29wZV9FdmVudHNbbmFtZXNwYWNlZEV2ZW50XSA9IHNjb3BlX0V2ZW50c1tuYW1lc3BhY2VkRXZlbnRdIHx8IFtdO1xyXG5cdFx0c2NvcGVfRXZlbnRzW25hbWVzcGFjZWRFdmVudF0ucHVzaChjYWxsYmFjayk7XHJcblxyXG5cdFx0Ly8gSWYgdGhlIGV2ZW50IGJvdW5kIGlzICd1cGRhdGUsJyBmaXJlIGl0IGltbWVkaWF0ZWx5IGZvciBhbGwgaGFuZGxlcy5cclxuXHRcdGlmICggbmFtZXNwYWNlZEV2ZW50LnNwbGl0KCcuJylbMF0gPT09ICd1cGRhdGUnICkge1xyXG5cdFx0XHRzY29wZV9IYW5kbGVzLmZvckVhY2goZnVuY3Rpb24oYSwgaW5kZXgpe1xyXG5cdFx0XHRcdGZpcmVFdmVudCgndXBkYXRlJywgaW5kZXgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIFVuZG8gYXR0YWNobWVudCBvZiBldmVudFxyXG5cdGZ1bmN0aW9uIHJlbW92ZUV2ZW50ICggbmFtZXNwYWNlZEV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBldmVudCA9IG5hbWVzcGFjZWRFdmVudC5zcGxpdCgnLicpWzBdLFxyXG5cdFx0XHRuYW1lc3BhY2UgPSBuYW1lc3BhY2VkRXZlbnQuc3Vic3RyaW5nKGV2ZW50Lmxlbmd0aCk7XHJcblxyXG5cdFx0T2JqZWN0LmtleXMoc2NvcGVfRXZlbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKCBiaW5kICl7XHJcblxyXG5cdFx0XHR2YXIgdEV2ZW50ID0gYmluZC5zcGxpdCgnLicpWzBdLFxyXG5cdFx0XHRcdHROYW1lc3BhY2UgPSBiaW5kLnN1YnN0cmluZyh0RXZlbnQubGVuZ3RoKTtcclxuXHJcblx0XHRcdGlmICggKCFldmVudCB8fCBldmVudCA9PT0gdEV2ZW50KSAmJiAoIW5hbWVzcGFjZSB8fCBuYW1lc3BhY2UgPT09IHROYW1lc3BhY2UpICkge1xyXG5cdFx0XHRcdGRlbGV0ZSBzY29wZV9FdmVudHNbYmluZF07XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Ly8gVXBkYXRlYWJsZTogbWFyZ2luLCBsaW1pdCwgc3RlcCwgcmFuZ2UsIGFuaW1hdGUsIHNuYXBcclxuXHRmdW5jdGlvbiB1cGRhdGVPcHRpb25zICggb3B0aW9uc1RvVXBkYXRlICkge1xyXG5cclxuXHRcdHZhciB2ID0gdmFsdWVHZXQoKSwgaSwgbmV3T3B0aW9ucyA9IHRlc3RPcHRpb25zKHtcclxuXHRcdFx0c3RhcnQ6IFswLCAwXSxcclxuXHRcdFx0bWFyZ2luOiBvcHRpb25zVG9VcGRhdGUubWFyZ2luLFxyXG5cdFx0XHRsaW1pdDogb3B0aW9uc1RvVXBkYXRlLmxpbWl0LFxyXG5cdFx0XHRzdGVwOiBvcHRpb25zVG9VcGRhdGUuc3RlcCxcclxuXHRcdFx0cmFuZ2U6IG9wdGlvbnNUb1VwZGF0ZS5yYW5nZSxcclxuXHRcdFx0YW5pbWF0ZTogb3B0aW9uc1RvVXBkYXRlLmFuaW1hdGUsXHJcblx0XHRcdHNuYXA6IG9wdGlvbnNUb1VwZGF0ZS5zbmFwID09PSB1bmRlZmluZWQgPyBvcHRpb25zLnNuYXAgOiBvcHRpb25zVG9VcGRhdGUuc25hcFxyXG5cdFx0fSk7XHJcblxyXG5cdFx0WydtYXJnaW4nLCAnbGltaXQnLCAnc3RlcCcsICdyYW5nZScsICdhbmltYXRlJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKXtcclxuXHRcdFx0aWYgKCBvcHRpb25zVG9VcGRhdGVbbmFtZV0gIT09IHVuZGVmaW5lZCApIHtcclxuXHRcdFx0XHRvcHRpb25zW25hbWVdID0gb3B0aW9uc1RvVXBkYXRlW25hbWVdO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRzY29wZV9TcGVjdHJ1bSA9IG5ld09wdGlvbnMuc3BlY3RydW07XHJcblxyXG5cdFx0Ly8gSW52YWxpZGF0ZSB0aGUgY3VycmVudCBwb3NpdGlvbmluZyBzbyB2YWx1ZVNldCBmb3JjZXMgYW4gdXBkYXRlLlxyXG5cdFx0c2NvcGVfTG9jYXRpb25zID0gWy0xLCAtMV07XHJcblx0XHR2YWx1ZVNldCh2KTtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHNjb3BlX0hhbmRsZXMubGVuZ3RoOyBpKysgKSB7XHJcblx0XHRcdGZpcmVFdmVudCgndXBkYXRlJywgaSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNsaWRlciB3YXMgYWxyZWFkeSBpbml0aWFsaXplZC5cclxuXHRpZiAoIHNjb3BlX1RhcmdldC5ub1VpU2xpZGVyICkge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdTbGlkZXIgd2FzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0fVxyXG5cclxuXHQvLyBDcmVhdGUgdGhlIGJhc2UgZWxlbWVudCwgaW5pdGlhbGlzZSBIVE1MIGFuZCBzZXQgY2xhc3Nlcy5cclxuXHQvLyBBZGQgaGFuZGxlcyBhbmQgbGlua3MuXHJcblx0c2NvcGVfQmFzZSA9IGFkZFNsaWRlciggb3B0aW9ucy5kaXIsIG9wdGlvbnMub3J0LCBzY29wZV9UYXJnZXQgKTtcclxuXHRzY29wZV9IYW5kbGVzID0gYWRkSGFuZGxlcyggb3B0aW9ucy5oYW5kbGVzLCBvcHRpb25zLmRpciwgc2NvcGVfQmFzZSApO1xyXG5cclxuXHQvLyBTZXQgdGhlIGNvbm5lY3QgY2xhc3Nlcy5cclxuXHRhZGRDb25uZWN0aW9uICggb3B0aW9ucy5jb25uZWN0LCBzY29wZV9UYXJnZXQsIHNjb3BlX0hhbmRsZXMgKTtcclxuXHJcblx0aWYgKCBvcHRpb25zLnBpcHMgKSB7XHJcblx0XHRwaXBzKG9wdGlvbnMucGlwcyk7XHJcblx0fVxyXG5cclxuXHRpZiAoIG9wdGlvbnMudG9vbHRpcHMgKSB7XHJcblx0XHR0b29sdGlwcygpO1xyXG5cdH1cclxuXHJcblx0c2NvcGVfU2VsZiA9IHtcclxuXHRcdGRlc3Ryb3k6IGRlc3Ryb3ksXHJcblx0XHRzdGVwczogZ2V0Q3VycmVudFN0ZXAsXHJcblx0XHRvbjogYmluZEV2ZW50LFxyXG5cdFx0b2ZmOiByZW1vdmVFdmVudCxcclxuXHRcdGdldDogdmFsdWVHZXQsXHJcblx0XHRzZXQ6IHZhbHVlU2V0LFxyXG5cdFx0dXBkYXRlT3B0aW9uczogdXBkYXRlT3B0aW9uc1xyXG5cdH07XHJcblxyXG5cdC8vIEF0dGFjaCB1c2VyIGV2ZW50cy5cclxuXHRldmVudHMoIG9wdGlvbnMuZXZlbnRzICk7XHJcblxyXG5cdHJldHVybiBzY29wZV9TZWxmO1xyXG5cclxufVxyXG5cclxuXHJcblx0Ly8gUnVuIHRoZSBzdGFuZGFyZCBpbml0aWFsaXplclxyXG5cdGZ1bmN0aW9uIGluaXRpYWxpemUgKCB0YXJnZXQsIG9yaWdpbmFsT3B0aW9ucyApIHtcclxuXHJcblx0XHRpZiAoICF0YXJnZXQubm9kZU5hbWUgKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignbm9VaVNsaWRlci5jcmVhdGUgcmVxdWlyZXMgYSBzaW5nbGUgZWxlbWVudC4nKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBUZXN0IHRoZSBvcHRpb25zIGFuZCBjcmVhdGUgdGhlIHNsaWRlciBlbnZpcm9ubWVudDtcclxuXHRcdHZhciBvcHRpb25zID0gdGVzdE9wdGlvbnMoIG9yaWdpbmFsT3B0aW9ucywgdGFyZ2V0ICksXHJcblx0XHRcdHNsaWRlciA9IGNsb3N1cmUoIHRhcmdldCwgb3B0aW9ucyApO1xyXG5cclxuXHRcdC8vIFVzZSB0aGUgcHVibGljIHZhbHVlIG1ldGhvZCB0byBzZXQgdGhlIHN0YXJ0IHZhbHVlcy5cclxuXHRcdHNsaWRlci5zZXQob3B0aW9ucy5zdGFydCk7XHJcblxyXG5cdFx0dGFyZ2V0Lm5vVWlTbGlkZXIgPSBzbGlkZXI7XHJcblx0XHRyZXR1cm4gc2xpZGVyO1xyXG5cdH1cclxuXHJcblx0Ly8gVXNlIGFuIG9iamVjdCBpbnN0ZWFkIG9mIGEgZnVuY3Rpb24gZm9yIGZ1dHVyZSBleHBhbnNpYmlsaXR5O1xyXG5cdHJldHVybiB7XHJcblx0XHRjcmVhdGU6IGluaXRpYWxpemVcclxuXHR9O1xyXG5cclxufSkpO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL2J1c2NoaWRvcy93b3JrL2dpdC9yZXN1bHQvfi9ub3Vpc2xpZGVyL2Rpc3RyaWJ1dGUvbm91aXNsaWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDUyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
]);